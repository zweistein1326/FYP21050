{"ast":null,"code":"// Random number generator - requires a PRNG backend, e.g. prng4.js\nimport { prng_newstate, rng_psize } from \"./prng4\";\nvar rng_state;\nvar rng_pool = null;\nvar rng_pptr; // Initialize the pool with junk if needed.\n\nif (rng_pool == null) {\n  rng_pool = [];\n  rng_pptr = 0;\n  var t = void 0;\n\n  if (window.crypto && window.crypto.getRandomValues) {\n    // Extract entropy (2048 bits) from RNG if available\n    var z = new Uint32Array(256);\n    window.crypto.getRandomValues(z);\n\n    for (t = 0; t < z.length; ++t) {\n      rng_pool[rng_pptr++] = z[t] & 255;\n    }\n  } // Use mouse events for entropy, if we do not have enough entropy by the time\n  // we need it, entropy will be generated by Math.random.\n\n\n  var count = 0;\n\n  var onMouseMoveListener_1 = function (ev) {\n    count = count || 0;\n\n    if (count >= 256 || rng_pptr >= rng_psize) {\n      if (window.removeEventListener) {\n        window.removeEventListener(\"mousemove\", onMouseMoveListener_1, false);\n      } else if (window.detachEvent) {\n        window.detachEvent(\"onmousemove\", onMouseMoveListener_1);\n      }\n\n      return;\n    }\n\n    try {\n      var mouseCoordinates = ev.x + ev.y;\n      rng_pool[rng_pptr++] = mouseCoordinates & 255;\n      count += 1;\n    } catch (e) {// Sometimes Firefox will deny permission to access event properties for some reason. Ignore.\n    }\n  };\n\n  if (window.addEventListener) {\n    window.addEventListener(\"mousemove\", onMouseMoveListener_1, false);\n  } else if (window.attachEvent) {\n    window.attachEvent(\"onmousemove\", onMouseMoveListener_1);\n  }\n}\n\nfunction rng_get_byte() {\n  if (rng_state == null) {\n    rng_state = prng_newstate(); // At this point, we may not have collected enough entropy.  If not, fall back to Math.random\n\n    while (rng_pptr < rng_psize) {\n      var random = Math.floor(65536 * Math.random());\n      rng_pool[rng_pptr++] = random & 255;\n    }\n\n    rng_state.init(rng_pool);\n\n    for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr) {\n      rng_pool[rng_pptr] = 0;\n    }\n\n    rng_pptr = 0;\n  } // TODO: allow reseeding after first request\n\n\n  return rng_state.next();\n}\n\nvar SecureRandom =\n/** @class */\nfunction () {\n  function SecureRandom() {}\n\n  SecureRandom.prototype.nextBytes = function (ba) {\n    for (var i = 0; i < ba.length; ++i) {\n      ba[i] = rng_get_byte();\n    }\n  };\n\n  return SecureRandom;\n}();\n\nexport { SecureRandom };","map":{"version":3,"sources":["/Users/sid/Desktop/SSOB/sso/client/node_modules/jsencrypt/lib/lib/jsbn/rng.js"],"names":["prng_newstate","rng_psize","rng_state","rng_pool","rng_pptr","t","window","crypto","getRandomValues","z","Uint32Array","length","count","onMouseMoveListener_1","ev","removeEventListener","detachEvent","mouseCoordinates","x","y","e","addEventListener","attachEvent","rng_get_byte","random","Math","floor","init","next","SecureRandom","prototype","nextBytes","ba","i"],"mappings":"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","sourcesContent":["// Random number generator - requires a PRNG backend, e.g. prng4.js\nimport { prng_newstate, rng_psize } from \"./prng4\";\nvar rng_state;\nvar rng_pool = null;\nvar rng_pptr;\n// Initialize the pool with junk if needed.\nif (rng_pool == null) {\n    rng_pool = [];\n    rng_pptr = 0;\n    var t = void 0;\n    if (window.crypto && window.crypto.getRandomValues) {\n        // Extract entropy (2048 bits) from RNG if available\n        var z = new Uint32Array(256);\n        window.crypto.getRandomValues(z);\n        for (t = 0; t < z.length; ++t) {\n            rng_pool[rng_pptr++] = z[t] & 255;\n        }\n    }\n    // Use mouse events for entropy, if we do not have enough entropy by the time\n    // we need it, entropy will be generated by Math.random.\n    var count = 0;\n    var onMouseMoveListener_1 = function (ev) {\n        count = count || 0;\n        if (count >= 256 || rng_pptr >= rng_psize) {\n            if (window.removeEventListener) {\n                window.removeEventListener(\"mousemove\", onMouseMoveListener_1, false);\n            }\n            else if (window.detachEvent) {\n                window.detachEvent(\"onmousemove\", onMouseMoveListener_1);\n            }\n            return;\n        }\n        try {\n            var mouseCoordinates = ev.x + ev.y;\n            rng_pool[rng_pptr++] = mouseCoordinates & 255;\n            count += 1;\n        }\n        catch (e) {\n            // Sometimes Firefox will deny permission to access event properties for some reason. Ignore.\n        }\n    };\n    if (window.addEventListener) {\n        window.addEventListener(\"mousemove\", onMouseMoveListener_1, false);\n    }\n    else if (window.attachEvent) {\n        window.attachEvent(\"onmousemove\", onMouseMoveListener_1);\n    }\n}\nfunction rng_get_byte() {\n    if (rng_state == null) {\n        rng_state = prng_newstate();\n        // At this point, we may not have collected enough entropy.  If not, fall back to Math.random\n        while (rng_pptr < rng_psize) {\n            var random = Math.floor(65536 * Math.random());\n            rng_pool[rng_pptr++] = random & 255;\n        }\n        rng_state.init(rng_pool);\n        for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr) {\n            rng_pool[rng_pptr] = 0;\n        }\n        rng_pptr = 0;\n    }\n    // TODO: allow reseeding after first request\n    return rng_state.next();\n}\nvar SecureRandom = /** @class */ (function () {\n    function SecureRandom() {\n    }\n    SecureRandom.prototype.nextBytes = function (ba) {\n        for (var i = 0; i < ba.length; ++i) {\n            ba[i] = rng_get_byte();\n        }\n    };\n    return SecureRandom;\n}());\nexport { SecureRandom };\n"]},"metadata":{},"sourceType":"module"}