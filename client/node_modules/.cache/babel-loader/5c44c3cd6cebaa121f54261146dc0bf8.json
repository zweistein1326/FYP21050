{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar crypto_1 = require(\"crypto\");\n\nvar fs_1 = require(\"fs\");\n\nvar path_1 = require(\"path\");\n\nvar generateKeyPairSync = require('crypto').generateKeyPairSync;\n\nvar NodeRSA =\n/** @class */\nfunction () {\n  /**\n   *\n   * @param publicKeyPath this should be absolute path\n   * @param privateKeyPath this should be absolute path\n   */\n  function NodeRSA(publicKeyPath, privateKeyPath, modulusLength) {\n    if (publicKeyPath === void 0) {\n      publicKeyPath = '';\n    }\n\n    if (privateKeyPath === void 0) {\n      privateKeyPath = '';\n    }\n\n    this.publicKeyPath = publicKeyPath;\n    this.privateKeyPath = privateKeyPath;\n    this.modulusLength = modulusLength || 2048;\n  }\n  /**\n   *\n   * @param {Object} args\n   * @param {String} args.publicKeyPath\n   * @param {String} args.text the text that you need to encrypt\n   *\n   * @returns {String}\n   */\n\n\n  NodeRSA.prototype.encryptStringWithRsaPublicKey = function (args) {\n    var text = args.text,\n        _a = args.keyPath,\n        keyPath = _a === void 0 ? this.publicKeyPath : _a;\n    var absolutePath = path_1.resolve(keyPath);\n    var publicKey = fs_1.readFileSync(absolutePath, 'utf8');\n    var buffer = Buffer.from(text);\n    var encrypted = crypto_1.publicEncrypt(publicKey, buffer);\n    return encrypted.toString('base64');\n  };\n  /**\n   *\n   * @param {Object} args\n   * @param {String} args.privateKeyPath\n   * @param {String} args.text the text that you need to decrypt\n   *\n   * @returns {String}\n   */\n\n\n  NodeRSA.prototype.decryptStringWithRsaPrivateKey = function (args) {\n    var text = args.text,\n        _a = args.keyPath,\n        keyPath = _a === void 0 ? this.privateKeyPath : _a;\n    var absolutePath = path_1.resolve(keyPath);\n    var privateKey = fs_1.readFileSync(absolutePath, 'utf8');\n    var buffer = Buffer.from(text, 'base64');\n    var decrypted = crypto_1.privateDecrypt(privateKey, buffer);\n    return decrypted.toString('utf8');\n  };\n\n  NodeRSA.prototype.createPrivateAndPublicKeys = function (modulusLength) {\n    if (modulusLength === void 0) {\n      modulusLength = this.modulusLength;\n    }\n\n    var _a = generateKeyPairSync('rsa', {\n      modulusLength: modulusLength,\n      publicKeyEncoding: {\n        type: 'spki',\n        format: 'pem'\n      },\n      privateKeyEncoding: {\n        type: 'pkcs8',\n        format: 'pem'\n      }\n    }),\n        privateKey = _a.privateKey,\n        publicKey = _a.publicKey;\n\n    return {\n      privateKey: privateKey,\n      publicKey: publicKey\n    };\n  };\n\n  return NodeRSA;\n}();\n\nexports.default = NodeRSA;","map":{"version":3,"sources":["/Users/sid/Desktop/SSOB/sso/client/node_modules/encrypt-rsa/build/index.js"],"names":["Object","defineProperty","exports","value","crypto_1","require","fs_1","path_1","generateKeyPairSync","NodeRSA","publicKeyPath","privateKeyPath","modulusLength","prototype","encryptStringWithRsaPublicKey","args","text","_a","keyPath","absolutePath","resolve","publicKey","readFileSync","buffer","Buffer","from","encrypted","publicEncrypt","toString","decryptStringWithRsaPrivateKey","privateKey","decrypted","privateDecrypt","createPrivateAndPublicKeys","publicKeyEncoding","type","format","privateKeyEncoding","default"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar crypto_1 = require(\"crypto\");\nvar fs_1 = require(\"fs\");\nvar path_1 = require(\"path\");\nvar generateKeyPairSync = require('crypto').generateKeyPairSync;\nvar NodeRSA = /** @class */ (function () {\n    /**\n     *\n     * @param publicKeyPath this should be absolute path\n     * @param privateKeyPath this should be absolute path\n     */\n    function NodeRSA(publicKeyPath, privateKeyPath, modulusLength) {\n        if (publicKeyPath === void 0) { publicKeyPath = ''; }\n        if (privateKeyPath === void 0) { privateKeyPath = ''; }\n        this.publicKeyPath = publicKeyPath;\n        this.privateKeyPath = privateKeyPath;\n        this.modulusLength = modulusLength || 2048;\n    }\n    /**\n     *\n     * @param {Object} args\n     * @param {String} args.publicKeyPath\n     * @param {String} args.text the text that you need to encrypt\n     *\n     * @returns {String}\n     */\n    NodeRSA.prototype.encryptStringWithRsaPublicKey = function (args) {\n        var text = args.text, _a = args.keyPath, keyPath = _a === void 0 ? this.publicKeyPath : _a;\n        var absolutePath = path_1.resolve(keyPath);\n        var publicKey = fs_1.readFileSync(absolutePath, 'utf8');\n        var buffer = Buffer.from(text);\n        var encrypted = crypto_1.publicEncrypt(publicKey, buffer);\n        return encrypted.toString('base64');\n    };\n    /**\n     *\n     * @param {Object} args\n     * @param {String} args.privateKeyPath\n     * @param {String} args.text the text that you need to decrypt\n     *\n     * @returns {String}\n     */\n    NodeRSA.prototype.decryptStringWithRsaPrivateKey = function (args) {\n        var text = args.text, _a = args.keyPath, keyPath = _a === void 0 ? this.privateKeyPath : _a;\n        var absolutePath = path_1.resolve(keyPath);\n        var privateKey = fs_1.readFileSync(absolutePath, 'utf8');\n        var buffer = Buffer.from(text, 'base64');\n        var decrypted = crypto_1.privateDecrypt(privateKey, buffer);\n        return decrypted.toString('utf8');\n    };\n    NodeRSA.prototype.createPrivateAndPublicKeys = function (modulusLength) {\n        if (modulusLength === void 0) { modulusLength = this.modulusLength; }\n        var _a = generateKeyPairSync('rsa', {\n            modulusLength: modulusLength,\n            publicKeyEncoding: {\n                type: 'spki',\n                format: 'pem',\n            },\n            privateKeyEncoding: {\n                type: 'pkcs8',\n                format: 'pem',\n            },\n        }), privateKey = _a.privateKey, publicKey = _a.publicKey;\n        return { privateKey: privateKey, publicKey: publicKey };\n    };\n    return NodeRSA;\n}());\nexports.default = NodeRSA;\n"]},"metadata":{},"sourceType":"script"}