{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@apollo/client/core'), require('@apollo/client/utilities'), require('graphql-anywhere/lib/async'), require('qs')) : typeof define === 'function' && define.amd ? define(['exports', '@apollo/client/core', '@apollo/client/utilities', 'graphql-anywhere/lib/async', 'qs'], factory) : factory(global['apollo-link-rest'] = {}, global.apolloClient.core, global.apolloClient.utilities, global.graphqlAnywhere.async, global.qs);\n})(this, function (exports, core, utilities, async, qs) {\n  'use strict';\n\n  var __extends = undefined && undefined.__extends || function () {\n    var extendStatics = function (d, b) {\n      extendStatics = Object.setPrototypeOf || {\n        __proto__: []\n      } instanceof Array && function (d, b) {\n        d.__proto__ = b;\n      } || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n      };\n\n      return extendStatics(d, b);\n    };\n\n    return function (d, b) {\n      extendStatics(d, b);\n\n      function __() {\n        this.constructor = d;\n      }\n\n      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n  }();\n\n  var __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n\n      return t;\n    };\n\n    return __assign.apply(this, arguments);\n  };\n\n  var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) {\n        try {\n          step(generator.next(value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n\n      function rejected(value) {\n        try {\n          step(generator[\"throw\"](value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n\n      function step(result) {\n        result.done ? resolve(result.value) : new P(function (resolve) {\n          resolve(result.value);\n        }).then(fulfilled, rejected);\n      }\n\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n  };\n\n  var __generator = undefined && undefined.__generator || function (thisArg, body) {\n    var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n        f,\n        y,\n        t,\n        g;\n    return g = {\n      next: verb(0),\n      \"throw\": verb(1),\n      \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n      return this;\n    }), g;\n\n    function verb(n) {\n      return function (v) {\n        return step([n, v]);\n      };\n    }\n\n    function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n\n      while (_) try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n\n      if (op[0] & 5) throw op[1];\n      return {\n        value: op[0] ? op[1] : void 0,\n        done: true\n      };\n    }\n  };\n\n  var _this = undefined;\n\n  var popOneSetOfArrayBracketsFromTypeName = function (typename) {\n    var noSpace = typename.replace(/\\s/g, '');\n    var sansOneBracketPair = noSpace.replace(/\\[(.*)\\]/, function (str, matchStr, offset, fullStr) {\n      return ((matchStr != null && matchStr.length) > 0 ? matchStr : null) || noSpace;\n    });\n    return sansOneBracketPair;\n  };\n\n  var addTypeNameToResult = function (result, __typename, typePatcher) {\n    if (Array.isArray(result)) {\n      var fixedTypename_1 = popOneSetOfArrayBracketsFromTypeName(__typename); // Recursion needed for multi-dimensional arrays\n\n      return result.map(function (e) {\n        return addTypeNameToResult(e, fixedTypename_1, typePatcher);\n      });\n    }\n\n    if (null == result || typeof result === 'number' || typeof result === 'boolean' || typeof result === 'string') {\n      return result;\n    }\n\n    return typePatcher(result, __typename, typePatcher);\n  };\n\n  var quickFindRestDirective = function (field) {\n    if (field.directives && field.directives.length) {\n      return field.directives.find(function (directive) {\n        return 'rest' === directive.name.value;\n      });\n    }\n\n    return null;\n  };\n  /**\n   * The way graphql works today, it doesn't hand us the AST tree for our query, it hands us the ROOT\n   * This method searches for REST-directive-attached nodes that are named to match this query.\n   *\n   * A little bit of wasted compute, but alternative would be a patch in graphql-anywhere.\n   *\n   * @param resultKey SearchKey for REST directive-attached item matching this sub-query\n   * @param current current node in the REST-JSON-response\n   * @param mainDefinition Parsed Query Definition\n   * @param fragmentMap Map of Named Fragments\n   * @param currentSelectionSet Current selection set we're filtering by\n   */\n\n\n  function findRestDirectivesThenInsertNullsForOmittedFields(resultKey, current, // currentSelectionSet starts at root, so wait until we're inside a Field tagged with an @rest directive to activate!\n  mainDefinition, fragmentMap, currentSelectionSet) {\n    if (currentSelectionSet == null || null == current || typeof current === 'number' || typeof current === 'boolean' || typeof current === 'string') {\n      return current;\n    }\n\n    currentSelectionSet.selections.forEach(function (node) {\n      if (utilities.isInlineFragment(node)) {\n        findRestDirectivesThenInsertNullsForOmittedFields(resultKey, current, mainDefinition, fragmentMap, node.selectionSet);\n      } else if (node.kind === 'FragmentSpread') {\n        var fragment = fragmentMap[node.name.value];\n        findRestDirectivesThenInsertNullsForOmittedFields(resultKey, current, mainDefinition, fragmentMap, fragment.selectionSet);\n      } else if (utilities.isField(node)) {\n        var name_1 = utilities.resultKeyNameFromField(node);\n\n        if (name_1 === resultKey && quickFindRestDirective(node) != null) {\n          // Jackpot! We found our selectionSet!\n          insertNullsForAnyOmittedFields(current, mainDefinition, fragmentMap, node.selectionSet);\n        } else {\n          findRestDirectivesThenInsertNullsForOmittedFields(resultKey, current, mainDefinition, fragmentMap, node.selectionSet);\n        }\n      } else {\n        // This will give a TypeScript build-time error if you did something wrong or the AST changes!\n        return function (node) {\n          throw new Error('Unhandled Node Type in SelectionSetNode.selections');\n        }(node);\n      }\n    }); // Return current to have our result pass to next link in async promise chain!\n\n    return current;\n  }\n  /**\n   * Recursively walks a handed object in parallel with the Query SelectionSet,\n   *  and inserts `null` for any field that is missing from the response.\n   *\n   * This is needed because ApolloClient will throw an error automatically if it's\n   *  missing -- effectively making all of rest-link's selections implicitly non-optional.\n   *\n   * If you want to implement required fields, you need to use typePatcher to *delete*\n   *  fields when they're null and you want the query to fail instead.\n   *\n   * @param current Current object we're patching\n   * @param mainDefinition Parsed Query Definition\n   * @param fragmentMap Map of Named Fragments\n   * @param currentSelectionSet Current selection set we're filtering by\n   */\n\n\n  function insertNullsForAnyOmittedFields(current, // currentSelectionSet starts at root, so wait until we're inside a Field tagged with an @rest directive to activate!\n  mainDefinition, fragmentMap, currentSelectionSet) {\n    if (null == current || typeof current === 'number' || typeof current === 'boolean' || typeof current === 'string') {\n      return;\n    }\n\n    if (Array.isArray(current)) {\n      // If our current value is an array, process our selection set for each entry.\n      current.forEach(function (c) {\n        return insertNullsForAnyOmittedFields(c, mainDefinition, fragmentMap, currentSelectionSet);\n      });\n      return;\n    }\n\n    currentSelectionSet.selections.forEach(function (node) {\n      if (utilities.isInlineFragment(node)) {\n        insertNullsForAnyOmittedFields(current, mainDefinition, fragmentMap, node.selectionSet);\n      } else if (node.kind === 'FragmentSpread') {\n        var fragment = fragmentMap[node.name.value];\n        insertNullsForAnyOmittedFields(current, mainDefinition, fragmentMap, fragment.selectionSet);\n      } else if (utilities.isField(node)) {\n        var value = current[node.name.value];\n        if (node.name.value === '__typename') ;else if (typeof value === 'undefined') {\n          // Patch in a null where the field would have been marked as missing\n          current[node.name.value] = null;\n        } else if (value != null && typeof value === 'object' && node.selectionSet != null) {\n          insertNullsForAnyOmittedFields(value, mainDefinition, fragmentMap, node.selectionSet);\n        }\n      } else {\n        // This will give a TypeScript build-time error if you did something wrong or the AST changes!\n        return function (node) {\n          throw new Error('Unhandled Node Type in SelectionSetNode.selections');\n        }(node);\n      }\n    });\n  }\n\n  var getEndpointOptions = function (endpoints, endpoint) {\n    var result = endpoints[endpoint || DEFAULT_ENDPOINT_KEY] || endpoints[DEFAULT_ENDPOINT_KEY];\n\n    if (typeof result === 'string') {\n      return {\n        uri: result\n      };\n    }\n\n    return __assign({\n      responseTransformer: null\n    }, result);\n  };\n  /** Replaces params in the path, keyed by colons */\n\n\n  var replaceLegacyParam = function (endpoint, name, value) {\n    if (value === undefined || name === undefined) {\n      return endpoint;\n    }\n\n    return endpoint.replace(\":\" + name, value);\n  };\n  /** Internal Tool that Parses Paths for RestLink -- This API should be considered experimental */\n\n\n  var PathBuilder =\n  /** @class */\n  function () {\n    function PathBuilder() {}\n\n    PathBuilder.replacerForPath = function (path) {\n      if (path in PathBuilder.cache) {\n        return PathBuilder.cache[path];\n      }\n\n      var queryOrigStartIndex = path.indexOf('?');\n      var pathBits = path.split(PathBuilder.argReplacement);\n      var chunkActions = [];\n      var hasBegunQuery = false;\n      pathBits.reduce(function (processedCount, bit) {\n        if (bit === '' || bit === '{}') {\n          // Empty chunk, do nothing\n          return processedCount + bit.length;\n        }\n\n        var nextIndex = processedCount + bit.length;\n\n        if (bit[0] === '{' && bit[bit.length - 1] === '}') {\n          // Replace some args!\n          var _keyPath_1 = bit.slice(1, bit.length - 1).split('.');\n\n          chunkActions.push(function (props, useQSEncoder) {\n            try {\n              var value = PathBuilderLookupValue(props, _keyPath_1);\n\n              if (!useQSEncoder || typeof value !== 'object' || value == null) {\n                return String(value);\n              } else {\n                return qs.stringify(value);\n              }\n            } catch (e) {\n              var key = [path, _keyPath_1.join('.')].join('|');\n\n              if (!(key in PathBuilder.warnTable)) {\n                console.warn('Warning: RestLink caught an error while unpacking', key, \"This tends to happen if you forgot to pass a parameter needed for creating an @rest(path, or if RestLink was configured to deeply unpack a path parameter that wasn't provided. This message will only log once per detected instance. Trouble-shooting hint: check @rest(path: and the variables provided to this query.\");\n                PathBuilder.warnTable[key] = true;\n              }\n\n              return '';\n            }\n          });\n        } else {\n          chunkActions.push(bit);\n\n          if (!hasBegunQuery && nextIndex >= queryOrigStartIndex) {\n            hasBegunQuery = true;\n            chunkActions.push(true);\n          }\n        }\n\n        return nextIndex;\n      }, 0);\n\n      var result = function (props) {\n        var hasEnteredQuery = false;\n        var tmp = chunkActions.reduce(function (accumulator, action) {\n          if (typeof action === 'string') {\n            return accumulator + action;\n          } else if (typeof action === 'boolean') {\n            hasEnteredQuery = true;\n            return accumulator;\n          } else {\n            return accumulator + action(props, hasEnteredQuery);\n          }\n        }, '');\n        return tmp;\n      };\n\n      return PathBuilder.cache[path] = result;\n    };\n    /** For accelerating the replacement of paths that are used a lot */\n\n\n    PathBuilder.cache = {};\n    /** Table to limit the amount of nagging (due to probable API Misuse) we do to once per path per launch */\n\n    PathBuilder.warnTable = {};\n    /** Regexp that finds things that are eligible for variable replacement */\n\n    PathBuilder.argReplacement = /({[._a-zA-Z0-9]*})/;\n    return PathBuilder;\n  }();\n  /** Private Helper Function */\n\n\n  function PathBuilderLookupValue(tmp, keyPath) {\n    if (keyPath.length === 0) {\n      return tmp;\n    }\n\n    var remainingKeyPath = keyPath.slice(); // Copy before mutating\n\n    var key = remainingKeyPath.shift();\n    return PathBuilderLookupValue(tmp[key], remainingKeyPath);\n  }\n  /**\n   * Some keys should be passed through transparently without normalizing/de-normalizing\n   */\n\n\n  var noMangleKeys = ['__typename'];\n  /** Recursively descends the provided object tree and converts all the keys */\n\n  var convertObjectKeys = function (object, __converter, keypath) {\n    if (keypath === void 0) {\n      keypath = [];\n    }\n\n    var converter = null;\n\n    if (__converter.length != 2) {\n      converter = function (name, keypath) {\n        return __converter(name);\n      };\n    } else {\n      converter = __converter;\n    }\n\n    if (object == null || typeof object !== 'object') {\n      // Object is a scalar or null / undefined => no keys to convert!\n      return object;\n    } // FileList/File are only available in some browser contexts\n    // Notably: *not available* in react-native.\n\n\n    if (global.FileList && object instanceof FileList || global.File && object instanceof File) {\n      // Object is a FileList or File object => no keys to convert!\n      return object;\n    }\n\n    if (Array.isArray(object)) {\n      return object.map(function (o, index) {\n        return convertObjectKeys(o, converter, keypath.concat([String(index)]));\n      });\n    }\n\n    return Object.keys(object).reduce(function (acc, key) {\n      var value = object[key];\n\n      if (noMangleKeys.indexOf(key) !== -1) {\n        acc[key] = value;\n        return acc;\n      }\n\n      var nestedKeyPath = keypath.concat([key]);\n      acc[converter(key, nestedKeyPath)] = convertObjectKeys(value, converter, nestedKeyPath);\n      return acc;\n    }, {});\n  };\n\n  var noOpNameNormalizer = function (name) {\n    return name;\n  };\n  /**\n   * Helper that makes sure our headers are of the right type to pass to Fetch\n   */\n\n\n  var normalizeHeaders = function (headers) {\n    // Make sure that our headers object is of the right type\n    if (headers instanceof Headers) {\n      return headers;\n    } else {\n      return new Headers(headers || {});\n    }\n  };\n  /**\n   * Returns a new Headers Group that contains all the headers.\n   * - If there are duplicates, they will be in the returned header set multiple times!\n   */\n\n\n  var concatHeadersMergePolicy = function () {\n    var headerGroups = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      headerGroups[_i] = arguments[_i];\n    }\n\n    return headerGroups.reduce(function (accumulator, current) {\n      if (!current) {\n        return accumulator;\n      }\n\n      if (!current.forEach) {\n        current = normalizeHeaders(current);\n      }\n\n      current.forEach(function (value, key) {\n        accumulator.append(key, value);\n      });\n      return accumulator;\n    }, new Headers());\n  };\n  /**\n   * This merge policy deletes any matching headers from the link's default headers.\n   * - Pass headersToOverride array & a headers arg to context and this policy will automatically be selected.\n   */\n\n\n  var overrideHeadersMergePolicy = function (linkHeaders, headersToOverride, requestHeaders) {\n    var result = new Headers();\n    linkHeaders.forEach(function (value, key) {\n      if (headersToOverride.indexOf(key) !== -1) {\n        return;\n      }\n\n      result.append(key, value);\n    });\n    return concatHeadersMergePolicy(result, requestHeaders || new Headers());\n  };\n\n  var makeOverrideHeadersMergePolicy = function (headersToOverride) {\n    return function (linkHeaders, requestHeaders) {\n      return overrideHeadersMergePolicy(linkHeaders, headersToOverride, requestHeaders);\n    };\n  };\n\n  var SUPPORTED_HTTP_VERBS = ['GET', 'POST', 'PUT', 'PATCH', 'DELETE'];\n\n  var validateRequestMethodForOperationType = function (method, operationType) {\n    switch (operationType) {\n      case 'query':\n        if (SUPPORTED_HTTP_VERBS.indexOf(method.toUpperCase()) !== -1) {\n          return;\n        }\n\n        throw new Error(\"A \\\"query\\\" operation can only support \\\"GET\\\" requests but got \\\"\" + method + \"\\\".\");\n\n      case 'mutation':\n        if (SUPPORTED_HTTP_VERBS.indexOf(method.toUpperCase()) !== -1) {\n          return;\n        }\n\n        throw new Error('\"mutation\" operations do not support that HTTP-verb');\n\n      case 'subscription':\n        throw new Error('A \"subscription\" operation is not supported yet.');\n\n      default:\n        var _exhaustiveCheck = operationType;\n        return _exhaustiveCheck;\n    }\n  };\n  /**\n   * Utility to build & throw a JS Error from a \"failed\" REST-response\n   * @param response: HTTP Response object for this request\n   * @param result: Promise that will render the body of the response\n   * @param message: Human-facing error message\n   */\n\n\n  var rethrowServerSideError = function (response, result, message) {\n    var error = new Error(message);\n    error.response = response;\n    error.statusCode = response.status;\n    error.result = result;\n    throw error;\n  };\n\n  var addTypeToNode = function (node, typename) {\n    if (node === null || node === undefined || typeof node !== 'object') {\n      return node;\n    }\n\n    if (!Array.isArray(node)) {\n      node['__typename'] = typename;\n      return node;\n    }\n\n    return node.map(function (item) {\n      return addTypeToNode(item, typename);\n    });\n  };\n\n  var resolver = function (fieldName, root, args, context, info) {\n    return __awaiter(_this, void 0, void 0, function () {\n      var directives, isLeaf, resultKey, exportVariablesByNode, exportVariables, copyExportVariables, aliasedNode, preAliasingNode, isATypeCall, isNotARestCall, credentials, endpoints, headers, customFetch, operationType, typePatcher, mainDefinition, fragmentDefinitions, fieldNameNormalizer, linkLevelNameDenormalizer, serializers, responseTransformer, fragmentMap, _a, path, endpoint, pathBuilder, endpointOption, neitherPathsProvided, allParams, pathWithParams, _b, method, type, bodyBuilder, bodyKey, perRequestNameDenormalizer, bodySerializer, body, overrideHeaders, maybeBody_1, serializedBody, requestParams, requestUrl, response, result, parsed, error_1, transformer, err_1;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            directives = info.directives, isLeaf = info.isLeaf, resultKey = info.resultKey;\n            exportVariablesByNode = context.exportVariablesByNode;\n            exportVariables = exportVariablesByNode.get(root) || {};\n\n            copyExportVariables = function (result) {\n              if (result instanceof Array) {\n                result.forEach(copyExportVariables);\n              } else {\n                // export variables are stored keyed on the node they are for\n                exportVariablesByNode.set(result, __assign({}, exportVariables));\n              }\n\n              return result;\n            };\n\n            aliasedNode = (root || {})[resultKey];\n            preAliasingNode = (root || {})[fieldName];\n\n            if (root && directives && directives.export) {\n              // @export(as:) is only supported with apollo-link-rest at this time\n              // so use the preAliasingNode as we're responsible for implementing aliasing!\n              exportVariables[directives.export.as] = preAliasingNode;\n            }\n\n            isATypeCall = directives && directives.type;\n\n            if (!isLeaf && isATypeCall) {\n              // @type(name: ) is only supported inside apollo-link-rest at this time\n              // so use the preAliasingNode as we're responsible for implementing aliasing!\n              // Also: exit early, since @type(name: ) && @rest() can't both exist on the same node.\n              if (directives.rest) {\n                throw new Error('Invalid use of @type(name: ...) directive on a call that also has @rest(...)');\n              }\n\n              copyExportVariables(preAliasingNode);\n              return [2\n              /*return*/\n              , addTypeToNode(preAliasingNode, directives.type.name)];\n            }\n\n            isNotARestCall = !directives || !directives.rest;\n\n            if (isNotARestCall) {\n              // This is not tagged with @rest()\n              // This might not belong to us so return the aliasNode version preferentially\n              return [2\n              /*return*/\n              , copyExportVariables(aliasedNode || preAliasingNode)];\n            }\n\n            credentials = context.credentials, endpoints = context.endpoints, headers = context.headers, customFetch = context.customFetch, operationType = context.operationType, typePatcher = context.typePatcher, mainDefinition = context.mainDefinition, fragmentDefinitions = context.fragmentDefinitions, fieldNameNormalizer = context.fieldNameNormalizer, linkLevelNameDenormalizer = context.fieldNameDenormalizer, serializers = context.serializers, responseTransformer = context.responseTransformer;\n            fragmentMap = utilities.createFragmentMap(fragmentDefinitions);\n            _a = directives.rest, path = _a.path, endpoint = _a.endpoint, pathBuilder = _a.pathBuilder;\n            endpointOption = getEndpointOptions(endpoints, endpoint);\n            neitherPathsProvided = path == null && pathBuilder == null;\n\n            if (neitherPathsProvided) {\n              throw new Error(\"One of (\\\"path\\\" | \\\"pathBuilder\\\") must be set in the @rest() directive. This request had neither, please add one\");\n            }\n\n            if (!pathBuilder) {\n              if (!path.includes(':')) {\n                // Colons are the legacy route, and aren't uri encoded anyhow.\n                pathBuilder = PathBuilder.replacerForPath(path);\n              } else {\n                console.warn(\"Deprecated: '@rest(path:' contains a ':' colon, this format will be removed in future versions\");\n\n                pathBuilder = function (_a) {\n                  var args = _a.args,\n                      exportVariables = _a.exportVariables;\n\n                  var legacyArgs = __assign({}, args, exportVariables);\n\n                  var pathWithParams = Object.keys(legacyArgs).reduce(function (acc, e) {\n                    return replaceLegacyParam(acc, e, legacyArgs[e]);\n                  }, path);\n\n                  if (pathWithParams.includes(':')) {\n                    throw new Error('Missing parameters to run query, specify it in the query params or use ' + 'an export directive. (If you need to use \":\" inside a variable string' + ' make sure to encode the variables properly using `encodeURIComponent' + '`. Alternatively see documentation about using pathBuilder.)');\n                  }\n\n                  return pathWithParams;\n                };\n              }\n            }\n\n            allParams = {\n              args: args,\n              exportVariables: exportVariables,\n              context: context,\n              '@rest': directives.rest,\n              replacer: pathBuilder\n            };\n            pathWithParams = pathBuilder(allParams);\n            _b = directives.rest, method = _b.method, type = _b.type, bodyBuilder = _b.bodyBuilder, bodyKey = _b.bodyKey, perRequestNameDenormalizer = _b.fieldNameDenormalizer, bodySerializer = _b.bodySerializer;\n\n            if (!method) {\n              method = 'GET';\n            }\n\n            if (!bodyKey) {\n              bodyKey = 'input';\n            }\n\n            body = undefined;\n            overrideHeaders = undefined;\n\n            if (-1 === ['GET', 'DELETE'].indexOf(method)) {\n              // Prepare our body!\n              if (!bodyBuilder) {\n                maybeBody_1 = allParams.exportVariables[bodyKey] || allParams.args && allParams.args[bodyKey];\n\n                if (!maybeBody_1) {\n                  throw new Error(\"[GraphQL \" + method + \" \" + operationType + \" using a REST call without a body]. No `\" + bodyKey + \"` was detected. Pass bodyKey, or bodyBuilder to the @rest() directive to resolve this.\");\n                }\n\n                bodyBuilder = function (argsWithExport) {\n                  return maybeBody_1;\n                };\n              }\n\n              body = convertObjectKeys(bodyBuilder(allParams), perRequestNameDenormalizer || linkLevelNameDenormalizer || noOpNameNormalizer);\n              serializedBody = void 0;\n\n              if (typeof bodySerializer === 'string') {\n                if (!serializers.hasOwnProperty(bodySerializer)) {\n                  throw new Error('\"bodySerializer\" must correspond to configured serializer. ' + (\"Please make sure to specify a serializer called \" + bodySerializer + \" in the \\\"bodySerializers\\\" property of the RestLink.\"));\n                }\n\n                serializedBody = serializers[bodySerializer](body, headers);\n              } else {\n                serializedBody = bodySerializer ? bodySerializer(body, headers) : serializers[DEFAULT_SERIALIZER_KEY](body, headers);\n              }\n\n              body = serializedBody.body;\n              overrideHeaders = new Headers(serializedBody.headers);\n            }\n\n            validateRequestMethodForOperationType(method, operationType || 'query');\n            requestParams = __assign({\n              method: method,\n              headers: overrideHeaders || headers,\n              body: body\n            }, credentials ? {\n              credentials: credentials\n            } : {});\n            requestUrl = \"\" + endpointOption.uri + pathWithParams;\n            return [4\n            /*yield*/\n            , (customFetch || fetch)(requestUrl, requestParams)];\n\n          case 1:\n            response = _c.sent();\n            context.responses.push(response);\n            if (!response.ok) return [3\n            /*break*/\n            , 2];\n\n            if (response.status === 204 || response.headers.get('Content-Length') === '0') {\n              // HTTP-204 means \"no-content\", similarly Content-Length implies the same\n              // This commonly occurs when you POST/PUT to the server, and it acknowledges\n              // success, but doesn't return your Resource.\n              result = {};\n            } else {\n              result = response;\n            }\n\n            return [3\n            /*break*/\n            , 9];\n\n          case 2:\n            if (!(response.status === 404)) return [3\n            /*break*/\n            , 3]; // In a GraphQL context a missing resource should be indicated by\n            // a null value rather than throwing a network error\n\n            result = null;\n            return [3\n            /*break*/\n            , 9];\n\n          case 3:\n            parsed = void 0;\n            _c.label = 4;\n\n          case 4:\n            _c.trys.push([4, 6,, 8]);\n\n            return [4\n            /*yield*/\n            , response.clone().json()];\n\n          case 5:\n            parsed = _c.sent();\n            return [3\n            /*break*/\n            , 8];\n\n          case 6:\n            error_1 = _c.sent();\n            return [4\n            /*yield*/\n            , response.clone().text()];\n\n          case 7:\n            // its not json\n            parsed = _c.sent();\n            return [3\n            /*break*/\n            , 8];\n\n          case 8:\n            rethrowServerSideError(response, parsed, \"Response not successful: Received status code \" + response.status);\n            _c.label = 9;\n\n          case 9:\n            transformer = endpointOption.responseTransformer || responseTransformer;\n            if (!transformer) return [3\n            /*break*/\n            , 14];\n            _c.label = 10;\n\n          case 10:\n            _c.trys.push([10, 12,, 13]);\n\n            return [4\n            /*yield*/\n            , transformer(result, type)];\n\n          case 11:\n            result = _c.sent();\n            return [3\n            /*break*/\n            , 13];\n\n          case 12:\n            err_1 = _c.sent();\n            console.warn('An error occurred in a responseTransformer:');\n            throw err_1;\n\n          case 13:\n            return [3\n            /*break*/\n            , 16];\n\n          case 14:\n            if (!(result && result.json)) return [3\n            /*break*/\n            , 16];\n            return [4\n            /*yield*/\n            , result.json()];\n\n          case 15:\n            result = _c.sent();\n            _c.label = 16;\n\n          case 16:\n            if (fieldNameNormalizer !== null) {\n              result = convertObjectKeys(result, fieldNameNormalizer);\n            }\n\n            result = findRestDirectivesThenInsertNullsForOmittedFields(resultKey, result, mainDefinition, fragmentMap, mainDefinition.selectionSet);\n            result = addTypeNameToResult(result, type, typePatcher);\n            return [2\n            /*return*/\n            , copyExportVariables(result)];\n        }\n      });\n    });\n  };\n  /**\n   * Default key to use when the @rest directive omits the \"endpoint\" parameter.\n   */\n\n\n  var DEFAULT_ENDPOINT_KEY = '';\n  /**\n   * Default key to use when the @rest directive omits the \"bodySerializers\" parameter.\n   */\n\n  var DEFAULT_SERIALIZER_KEY = '';\n\n  var DEFAULT_JSON_SERIALIZER = function (data, headers) {\n    if (!headers.has('content-type')) {\n      headers.append('Content-Type', 'application/json');\n    }\n\n    return {\n      body: JSON.stringify(data),\n      headers: headers\n    };\n  };\n\n  var CONNECTION_REMOVE_CONFIG = {\n    test: function (directive) {\n      return directive.name.value === 'rest';\n    },\n    remove: true\n  };\n  /**\n   * RestLink is an apollo-link for communicating with REST services using GraphQL on the client-side\n   */\n\n  var RestLink =\n  /** @class */\n  function (_super) {\n    __extends(RestLink, _super);\n\n    function RestLink(_a) {\n      var _b;\n\n      var uri = _a.uri,\n          endpoints = _a.endpoints,\n          headers = _a.headers,\n          fieldNameNormalizer = _a.fieldNameNormalizer,\n          fieldNameDenormalizer = _a.fieldNameDenormalizer,\n          typePatcher = _a.typePatcher,\n          customFetch = _a.customFetch,\n          credentials = _a.credentials,\n          bodySerializers = _a.bodySerializers,\n          defaultSerializer = _a.defaultSerializer,\n          responseTransformer = _a.responseTransformer;\n\n      var _this = _super.call(this) || this;\n\n      var fallback = {};\n      fallback[DEFAULT_ENDPOINT_KEY] = uri || '';\n      _this.endpoints = Object.assign({}, endpoints || fallback);\n\n      if (uri == null && endpoints == null) {\n        throw new Error('A RestLink must be initialized with either 1 uri, or a map of keyed-endpoints');\n      }\n\n      if (uri != null) {\n        var currentDefaultURI = (endpoints || {})[DEFAULT_ENDPOINT_KEY];\n\n        if (currentDefaultURI != null && currentDefaultURI != uri) {\n          throw new Error(\"RestLink was configured with a default uri that doesn't match what's passed in to the endpoints map.\");\n        }\n\n        _this.endpoints[DEFAULT_ENDPOINT_KEY] = uri;\n      }\n\n      if (_this.endpoints[DEFAULT_ENDPOINT_KEY] == null) {\n        console.warn('RestLink configured without a default URI. All @rest(â€¦) directives must provide an endpoint key!');\n      }\n\n      if (typePatcher == null) {\n        _this.typePatcher = function (result, __typename, _2) {\n          return __assign({\n            __typename: __typename\n          }, result);\n        };\n      } else if (!Array.isArray(typePatcher) && typeof typePatcher === 'object' && Object.keys(typePatcher).map(function (key) {\n        return typePatcher[key];\n      }).reduce( // Make sure all of the values are patcher-functions\n      function (current, patcher) {\n        return current && typeof patcher === 'function';\n      }, true)) {\n        var table_1 = typePatcher;\n\n        _this.typePatcher = function (data, outerType, patchDeeper) {\n          var __typename = data.__typename || outerType;\n\n          if (Array.isArray(data)) {\n            return data.map(function (d) {\n              return patchDeeper(d, __typename, patchDeeper);\n            });\n          }\n\n          var subPatcher = table_1[__typename] || function (result) {\n            return result;\n          };\n\n          return __assign({\n            __typename: __typename\n          }, subPatcher(data, __typename, patchDeeper));\n        };\n      } else {\n        throw new Error('RestLink was configured with a typePatcher of invalid type!');\n      }\n\n      if (bodySerializers && bodySerializers.hasOwnProperty(DEFAULT_SERIALIZER_KEY)) {\n        console.warn('RestLink was configured to override the default serializer! This may result in unexpected behavior');\n      }\n\n      _this.responseTransformer = responseTransformer || null;\n      _this.fieldNameNormalizer = fieldNameNormalizer || null;\n      _this.fieldNameDenormalizer = fieldNameDenormalizer || null;\n      _this.headers = normalizeHeaders(headers);\n      _this.credentials = credentials || null;\n      _this.customFetch = customFetch;\n      _this.serializers = __assign((_b = {}, _b[DEFAULT_SERIALIZER_KEY] = defaultSerializer || DEFAULT_JSON_SERIALIZER, _b), bodySerializers || {});\n      _this.processedDocuments = new Map();\n      return _this;\n    }\n\n    RestLink.prototype.removeRestSetsFromDocument = function (query) {\n      var cached = this.processedDocuments.get(query);\n      if (cached) return cached;\n      utilities.checkDocument(query);\n      var docClone = utilities.removeDirectivesFromDocument([CONNECTION_REMOVE_CONFIG], query);\n      this.processedDocuments.set(query, docClone);\n      return docClone;\n    };\n\n    RestLink.prototype.request = function (operation, forward) {\n      var query = operation.query,\n          variables = operation.variables,\n          getContext = operation.getContext,\n          setContext = operation.setContext;\n      var context = getContext();\n      var isRestQuery = utilities.hasDirectives(['rest'], query);\n\n      if (!isRestQuery) {\n        return forward(operation);\n      }\n\n      var nonRest = this.removeRestSetsFromDocument(query); // 1. Use the user's merge policy if any\n\n      var headersMergePolicy = context.headersMergePolicy;\n\n      if (headersMergePolicy == null && Array.isArray(context.headersToOverride)) {\n        // 2.a. Override just the passed in headers, if user provided that optional array\n        headersMergePolicy = makeOverrideHeadersMergePolicy(context.headersToOverride);\n      } else if (headersMergePolicy == null) {\n        // 2.b Glue the link (default) headers to the request-context headers\n        headersMergePolicy = concatHeadersMergePolicy;\n      }\n\n      var headers = headersMergePolicy(this.headers, context.headers);\n\n      if (!headers.has('Accept')) {\n        // Since we assume a json body on successful responses set the Accept\n        // header accordingly if it is not provided by the user\n        headers.append('Accept', 'application/json');\n      }\n\n      var credentials = context.credentials || this.credentials;\n      var queryWithTypename = utilities.addTypenameToDocument(query);\n      var mainDefinition = utilities.getMainDefinition(query);\n      var fragmentDefinitions = utilities.getFragmentDefinitions(query);\n      var operationType = (mainDefinition || {}).operation || 'query';\n      var requestContext = {\n        headers: headers,\n        endpoints: this.endpoints,\n        // Provide an empty map for this request's exports to be stuffed into\n        exportVariablesByNode: new Map(),\n        credentials: credentials,\n        customFetch: this.customFetch,\n        operationType: operationType,\n        fieldNameNormalizer: this.fieldNameNormalizer,\n        fieldNameDenormalizer: this.fieldNameDenormalizer,\n        mainDefinition: mainDefinition,\n        fragmentDefinitions: fragmentDefinitions,\n        typePatcher: this.typePatcher,\n        serializers: this.serializers,\n        responses: [],\n        responseTransformer: this.responseTransformer\n      };\n      var resolverOptions = {};\n      var obs;\n\n      if (nonRest && forward) {\n        operation.query = nonRest;\n        obs = forward(operation);\n      } else obs = core.Observable.of({\n        data: {}\n      });\n\n      return obs.flatMap(function (_a) {\n        var data = _a.data,\n            errors = _a.errors;\n        return new core.Observable(function (observer) {\n          async.graphql(resolver, queryWithTypename, data, requestContext, variables, resolverOptions).then(function (data) {\n            setContext({\n              restResponses: (context.restResponses || []).concat(requestContext.responses)\n            });\n            observer.next({\n              data: data,\n              errors: errors\n            });\n            observer.complete();\n          }).catch(function (err) {\n            if (err.name === 'AbortError') return;\n\n            if (err.result && err.result.errors) {\n              observer.next(err.result);\n            }\n\n            observer.error(err);\n          });\n        });\n      });\n    };\n\n    return RestLink;\n  }(core.ApolloLink);\n\n  exports.RestLink = RestLink;\n  exports.PathBuilder = PathBuilder;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"sources":["../src/restLink.ts"],"names":["isInlineFragment","isField","resultKeyNameFromField","qs.stringify","createFragmentMap","ApolloLink","checkDocument","removeDirectivesFromDocument","hasDirectives","addTypenameToDocument","getMainDefinition","getFragmentDefinitions","Observable","graphql"],"mappings":"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","sourcesContent":["import {\n  OperationTypeNode,\n  OperationDefinitionNode,\n  FragmentDefinitionNode,\n  // Query Nodes\n  DirectiveNode,\n  DocumentNode,\n  FieldNode,\n  SelectionSetNode,\n} from 'graphql';\nimport {\n  ApolloLink,\n  Observable,\n  Operation,\n  NextLink,\n  FetchResult,\n} from '@apollo/client/core';\nimport {\n  hasDirectives,\n  getMainDefinition,\n  getFragmentDefinitions,\n  createFragmentMap,\n  addTypenameToDocument,\n  FragmentMap,\n  isField,\n  isInlineFragment,\n  resultKeyNameFromField,\n  checkDocument,\n  removeDirectivesFromDocument,\n} from '@apollo/client/utilities';\n\nimport { graphql } from 'graphql-anywhere/lib/async';\nimport { Resolver, ExecInfo } from 'graphql-anywhere';\n\nimport * as qs from 'qs';\n\nexport namespace RestLink {\n  export type URI = string;\n\n  export type Endpoint = string;\n\n  export interface EndpointOptions {\n    uri: Endpoint;\n    responseTransformer?: ResponseTransformer | null;\n  }\n\n  export interface Endpoints {\n    [endpointKey: string]: Endpoint | EndpointOptions;\n  }\n\n  export type Header = string;\n  export interface HeadersHash {\n    [headerKey: string]: Header;\n  }\n  export type InitializationHeaders = HeadersHash | Headers | string[][];\n\n  export type HeadersMergePolicy = (...headerGroups: Headers[]) => Headers;\n\n  export interface FieldNameNormalizer {\n    (fieldName: string, keypath?: string[]): string;\n  }\n\n  /** injects __typename using user-supplied code */\n  export interface FunctionalTypePatcher {\n    (data: any, outerType: string, patchDeeper: FunctionalTypePatcher): any;\n  }\n  /** Table of mappers that help inject __typename per type described therein */\n  export interface TypePatcherTable {\n    [typename: string]: FunctionalTypePatcher;\n  }\n\n  export interface SerializedBody {\n    body: any;\n    headers: InitializationHeaders;\n  }\n\n  export interface Serializer {\n    (data: any, headers: Headers): SerializedBody;\n  }\n\n  export interface Serializers {\n    [bodySerializer: string]: Serializer;\n  }\n\n  export type CustomFetch = (\n    request: RequestInfo,\n    init: RequestInit,\n  ) => Promise<Response>;\n\n  export type ResponseTransformer = (data: any, typeName: string) => any;\n\n  export interface RestLinkHelperProps {\n    /** Arguments passed in via normal graphql parameters */\n    args: { [key: string]: any };\n    /** Arguments added via @export(as: ) directives */\n    exportVariables: { [key: string]: any };\n    /** Arguments passed directly to @rest(params: ) */\n    // params: { [key: string]: any };\n    /** Apollo Context */\n    context: { [key: string]: any };\n    /** All arguments passed to the `@rest(...)` directive */\n    '@rest': { [key: string]: any };\n  }\n  export interface PathBuilderProps extends RestLinkHelperProps {\n    replacer: (opts: RestLinkHelperProps) => string;\n  }\n\n  /**\n   * Used for any Error from the server when requests:\n   * - terminate with HTTP Status >= 300\n   * - and the response contains no data or errors\n   */\n  export type ServerError = Error & {\n    response: Response;\n    result: any;\n    statusCode: number;\n  };\n\n  export type Options = {\n    /**\n     * The URI to use when fetching operations.\n     *\n     * Optional if endpoints provides a default.\n     */\n    uri?: URI;\n\n    /**\n     * A root endpoint (uri) to apply paths to or a map of endpoints.\n     */\n    endpoints?: Endpoints;\n\n    /**\n     * An object representing values to be sent as headers on the request.\n     */\n    headers?: InitializationHeaders;\n\n    /**\n     * A function that takes the response field name and converts it into a GraphQL compliant name\n     *\n     * @note This is called *before* @see typePatcher so that it happens after\n     *       optional-field-null-insertion.\n     */\n    fieldNameNormalizer?: FieldNameNormalizer;\n\n    /**\n     * A function that takes a GraphQL-compliant field name and converts it back into an endpoint-specific name\n     * Can be overridden at the mutation-call-site (in the rest-directive).\n     */\n    fieldNameDenormalizer?: FieldNameNormalizer;\n\n    /**\n     * Structure to allow you to specify the __typename when you have nested objects in your REST response!\n     *\n     * If you want to force Required Properties, you can throw an error in your patcher,\n     *  or `delete` a field from the data response provided to your typePatcher function!\n     *\n     * @note: This is called *after* @see fieldNameNormalizer because that happens\n     *        after optional-nulls insertion, and those would clobber normalized names.\n     *\n     * @warning: We're not thrilled with this API, and would love a better alternative before we get to 1.0.0\n     *           Please see proposals considered in https://github.com/apollographql/apollo-link-rest/issues/48\n     *           And consider submitting alternate solutions to the problem!\n     */\n    typePatcher?: TypePatcherTable;\n\n    /**\n     * The credentials policy you want to use for the fetch call.\n     */\n    credentials?: 'omit' | 'same-origin' | 'include';\n\n    /**\n     * Use a custom fetch to handle REST calls.\n     */\n    customFetch?: CustomFetch;\n\n    /**\n     * Add serializers that will serialize the body before it is emitted and will pass on\n     * headers to update the request.\n     */\n    bodySerializers?: Serializers;\n\n    /**\n     * Set the default serializer for the link\n     * @default JSON serialization\n     */\n    defaultSerializer?: Serializer;\n\n    /**\n     * Parse the response body of an HTTP request into the format that Apollo expects.\n     */\n    responseTransformer?: ResponseTransformer;\n  };\n\n  /** @rest(...) Directive Options */\n  export interface DirectiveOptions {\n    /**\n     * What HTTP method to use.\n     * @default `GET`\n     */\n    method?: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';\n    /** What GraphQL type to name the response */\n    type?: string;\n    /**\n     * What path (including query) to use\n     * - @optional if you provide @see DirectiveOptions.pathBuilder\n     */\n    path?: string;\n    /**\n     * What endpoint to select from the map of endpoints available to this link.\n     * @default `RestLink.endpoints[DEFAULT_ENDPOINT_KEY]`\n     */\n    endpoint?: string;\n    /**\n     * Function that constructs a request path out of the Environmental\n     *  state when processing this @rest(...) call.\n     *\n     * - @optional if you provide: @see DirectiveOptions.path\n     * - **note**: providing this function means it's your responsibility to call\n     *             encodeURIComponent directly if needed!\n     *\n     * Warning: This is an Advanced API and we are looking for syntactic & ergonomics feedback.\n     */\n    pathBuilder?: (props: PathBuilderProps) => string;\n    /**\n     * Optional method that constructs a RequestBody out of the Environmental state\n     * when processing this @rest(...) call.\n     * @default function that extracts the bodyKey from the args.\n     *\n     * Warning: This is an Advanced API and we are looking for syntactic & ergonomics feedback.\n     */\n    bodyBuilder?: (props: RestLinkHelperProps) => object;\n    /**\n     * Optional field that defines the name of the env var to extract and use as the body\n     * @default \"input\"\n     * @see https://dev-blog.apollodata.com/designing-graphql-mutations-e09de826ed97\n     */\n    bodyKey?: string;\n\n    /**\n     * Optional serialization function or a key that will be used look up the serializer to serialize the request body before transport.\n     * @default if null will fallback to the default serializer\n     */\n    bodySerializer?: RestLink.Serializer | string;\n\n    /**\n     * A per-request name denormalizer, this permits special endpoints to have their\n     * field names remapped differently from the default.\n     * @default Uses RestLink.fieldNameDenormalizer\n     */\n    fieldNameDenormalizer?: RestLink.FieldNameNormalizer;\n    /**\n     * A method to allow insertion of __typename deep in response objects\n     */\n    typePatcher?: RestLink.FunctionalTypePatcher;\n  }\n}\n\nconst popOneSetOfArrayBracketsFromTypeName = (typename: string): string => {\n  const noSpace = typename.replace(/\\s/g, '');\n  const sansOneBracketPair = noSpace.replace(\n    /\\[(.*)\\]/,\n    (str, matchStr, offset, fullStr) => {\n      return (\n        ((matchStr != null && matchStr.length) > 0 ? matchStr : null) || noSpace\n      );\n    },\n  );\n  return sansOneBracketPair;\n};\n\nconst addTypeNameToResult = (\n  result: any[] | object,\n  __typename: string,\n  typePatcher: RestLink.FunctionalTypePatcher,\n): any[] | object => {\n  if (Array.isArray(result)) {\n    const fixedTypename = popOneSetOfArrayBracketsFromTypeName(__typename);\n    // Recursion needed for multi-dimensional arrays\n    return result.map(e => addTypeNameToResult(e, fixedTypename, typePatcher));\n  }\n  if (\n    null == result ||\n    typeof result === 'number' ||\n    typeof result === 'boolean' ||\n    typeof result === 'string'\n  ) {\n    return result;\n  }\n  return typePatcher(result, __typename, typePatcher);\n};\n\nconst quickFindRestDirective = (field: FieldNode): DirectiveNode | null => {\n  if (field.directives && field.directives.length) {\n    return field.directives.find(directive => 'rest' === directive.name.value);\n  }\n  return null;\n};\n/**\n * The way graphql works today, it doesn't hand us the AST tree for our query, it hands us the ROOT\n * This method searches for REST-directive-attached nodes that are named to match this query.\n *\n * A little bit of wasted compute, but alternative would be a patch in graphql-anywhere.\n *\n * @param resultKey SearchKey for REST directive-attached item matching this sub-query\n * @param current current node in the REST-JSON-response\n * @param mainDefinition Parsed Query Definition\n * @param fragmentMap Map of Named Fragments\n * @param currentSelectionSet Current selection set we're filtering by\n */\nfunction findRestDirectivesThenInsertNullsForOmittedFields(\n  resultKey: string,\n  current: any[] | object, // currentSelectionSet starts at root, so wait until we're inside a Field tagged with an @rest directive to activate!\n  mainDefinition: OperationDefinitionNode | FragmentDefinitionNode,\n  fragmentMap: FragmentMap,\n  currentSelectionSet: SelectionSetNode,\n): any[] | object {\n  if (\n    currentSelectionSet == null ||\n    null == current ||\n    typeof current === 'number' ||\n    typeof current === 'boolean' ||\n    typeof current === 'string'\n  ) {\n    return current;\n  }\n  currentSelectionSet.selections.forEach(node => {\n    if (isInlineFragment(node)) {\n      findRestDirectivesThenInsertNullsForOmittedFields(\n        resultKey,\n        current,\n        mainDefinition,\n        fragmentMap,\n        node.selectionSet,\n      );\n    } else if (node.kind === 'FragmentSpread') {\n      const fragment = fragmentMap[node.name.value];\n      findRestDirectivesThenInsertNullsForOmittedFields(\n        resultKey,\n        current,\n        mainDefinition,\n        fragmentMap,\n        fragment.selectionSet,\n      );\n    } else if (isField(node)) {\n      const name = resultKeyNameFromField(node);\n      if (name === resultKey && quickFindRestDirective(node) != null) {\n        // Jackpot! We found our selectionSet!\n        insertNullsForAnyOmittedFields(\n          current,\n          mainDefinition,\n          fragmentMap,\n          node.selectionSet,\n        );\n      } else {\n        findRestDirectivesThenInsertNullsForOmittedFields(\n          resultKey,\n          current,\n          mainDefinition,\n          fragmentMap,\n          node.selectionSet,\n        );\n      }\n    } else {\n      // This will give a TypeScript build-time error if you did something wrong or the AST changes!\n      return ((node: never): never => {\n        throw new Error('Unhandled Node Type in SelectionSetNode.selections');\n      })(node);\n    }\n  });\n  // Return current to have our result pass to next link in async promise chain!\n  return current;\n}\n/**\n * Recursively walks a handed object in parallel with the Query SelectionSet,\n *  and inserts `null` for any field that is missing from the response.\n *\n * This is needed because ApolloClient will throw an error automatically if it's\n *  missing -- effectively making all of rest-link's selections implicitly non-optional.\n *\n * If you want to implement required fields, you need to use typePatcher to *delete*\n *  fields when they're null and you want the query to fail instead.\n *\n * @param current Current object we're patching\n * @param mainDefinition Parsed Query Definition\n * @param fragmentMap Map of Named Fragments\n * @param currentSelectionSet Current selection set we're filtering by\n */\nfunction insertNullsForAnyOmittedFields(\n  current: any[] | object, // currentSelectionSet starts at root, so wait until we're inside a Field tagged with an @rest directive to activate!\n  mainDefinition: OperationDefinitionNode | FragmentDefinitionNode,\n  fragmentMap: FragmentMap,\n  currentSelectionSet: SelectionSetNode,\n): void {\n  if (\n    null == current ||\n    typeof current === 'number' ||\n    typeof current === 'boolean' ||\n    typeof current === 'string'\n  ) {\n    return;\n  }\n  if (Array.isArray(current)) {\n    // If our current value is an array, process our selection set for each entry.\n    current.forEach(c =>\n      insertNullsForAnyOmittedFields(\n        c,\n        mainDefinition,\n        fragmentMap,\n        currentSelectionSet,\n      ),\n    );\n    return;\n  }\n  currentSelectionSet.selections.forEach(node => {\n    if (isInlineFragment(node)) {\n      insertNullsForAnyOmittedFields(\n        current,\n        mainDefinition,\n        fragmentMap,\n        node.selectionSet,\n      );\n    } else if (node.kind === 'FragmentSpread') {\n      const fragment = fragmentMap[node.name.value];\n      insertNullsForAnyOmittedFields(\n        current,\n        mainDefinition,\n        fragmentMap,\n        fragment.selectionSet,\n      );\n    } else if (isField(node)) {\n      const value = current[node.name.value];\n      if (node.name.value === '__typename') {\n        // Don't mess with special fields like __typename\n      } else if (typeof value === 'undefined') {\n        // Patch in a null where the field would have been marked as missing\n        current[node.name.value] = null;\n      } else if (\n        value != null &&\n        typeof value === 'object' &&\n        node.selectionSet != null\n      ) {\n        insertNullsForAnyOmittedFields(\n          value,\n          mainDefinition,\n          fragmentMap,\n          node.selectionSet,\n        );\n      } else {\n        // Other types (string, number) do not need recursive patching!\n      }\n    } else {\n      // This will give a TypeScript build-time error if you did something wrong or the AST changes!\n      return ((node: never): never => {\n        throw new Error('Unhandled Node Type in SelectionSetNode.selections');\n      })(node);\n    }\n  });\n}\n\nconst getEndpointOptions = (\n  endpoints: RestLink.Endpoints,\n  endpoint: RestLink.Endpoint,\n): RestLink.EndpointOptions => {\n  const result =\n    endpoints[endpoint || DEFAULT_ENDPOINT_KEY] ||\n    endpoints[DEFAULT_ENDPOINT_KEY];\n\n  if (typeof result === 'string') {\n    return { uri: result };\n  }\n\n  return {\n    responseTransformer: null,\n    ...result,\n  };\n};\n\n/** Replaces params in the path, keyed by colons */\nconst replaceLegacyParam = (\n  endpoint: string,\n  name: string,\n  value: string,\n): string => {\n  if (value === undefined || name === undefined) {\n    return endpoint;\n  }\n  return endpoint.replace(`:${name}`, value);\n};\n\n/** Internal Tool that Parses Paths for RestLink -- This API should be considered experimental */\nexport class PathBuilder {\n  /** For accelerating the replacement of paths that are used a lot */\n  private static cache: {\n    [path: string]: (props: RestLink.PathBuilderProps) => string;\n  } = {};\n  /** Table to limit the amount of nagging (due to probable API Misuse) we do to once per path per launch */\n  private static warnTable: { [key: string]: true } = {};\n  /** Regexp that finds things that are eligible for variable replacement */\n  private static argReplacement = /({[._a-zA-Z0-9]*})/;\n\n  static replacerForPath(\n    path: string,\n  ): (props: RestLink.PathBuilderProps) => string {\n    if (path in PathBuilder.cache) {\n      return PathBuilder.cache[path];\n    }\n\n    const queryOrigStartIndex = path.indexOf('?');\n    const pathBits = path.split(PathBuilder.argReplacement);\n\n    const chunkActions: Array<\n      | true // We're enabling the qs-encoder\n      | string // This is a raw string bit, don't mess with it\n      | ((props: RestLink.RestLinkHelperProps, useQSEncoder: boolean) => string)\n    > = [];\n\n    let hasBegunQuery = false;\n    pathBits.reduce((processedCount, bit) => {\n      if (bit === '' || bit === '{}') {\n        // Empty chunk, do nothing\n        return processedCount + bit.length;\n      }\n      const nextIndex = processedCount + bit.length;\n      if (bit[0] === '{' && bit[bit.length - 1] === '}') {\n        // Replace some args!\n        const _keyPath = bit.slice(1, bit.length - 1).split('.');\n\n        chunkActions.push(\n          (props: RestLink.RestLinkHelperProps, useQSEncoder: boolean) => {\n            try {\n              const value = PathBuilderLookupValue(props, _keyPath);\n              if (\n                !useQSEncoder ||\n                (typeof value !== 'object' || value == null)\n              ) {\n                return String(value);\n              } else {\n                return qs.stringify(value);\n              }\n            } catch (e) {\n              const key = [path, _keyPath.join('.')].join('|');\n              if (!(key in PathBuilder.warnTable)) {\n                console.warn(\n                  'Warning: RestLink caught an error while unpacking',\n                  key,\n                  \"This tends to happen if you forgot to pass a parameter needed for creating an @rest(path, or if RestLink was configured to deeply unpack a path parameter that wasn't provided. This message will only log once per detected instance. Trouble-shooting hint: check @rest(path: and the variables provided to this query.\",\n                );\n                PathBuilder.warnTable[key] = true;\n              }\n              return '';\n            }\n          },\n        );\n      } else {\n        chunkActions.push(bit);\n        if (!hasBegunQuery && nextIndex >= queryOrigStartIndex) {\n          hasBegunQuery = true;\n          chunkActions.push(true);\n        }\n      }\n      return nextIndex;\n    }, 0);\n\n    const result: (props: RestLink.PathBuilderProps) => string = props => {\n      let hasEnteredQuery = false;\n      const tmp = chunkActions.reduce((accumulator: string, action): string => {\n        if (typeof action === 'string') {\n          return accumulator + action;\n        } else if (typeof action === 'boolean') {\n          hasEnteredQuery = true;\n          return accumulator;\n        } else {\n          return accumulator + action(props, hasEnteredQuery);\n        }\n      }, '') as string;\n      return tmp;\n    };\n    return (PathBuilder.cache[path] = result);\n  }\n}\n\n/** Private Helper Function */\nfunction PathBuilderLookupValue(tmp: object, keyPath: string[]) {\n  if (keyPath.length === 0) {\n    return tmp;\n  }\n  const remainingKeyPath = [...keyPath]; // Copy before mutating\n  const key = remainingKeyPath.shift();\n  return PathBuilderLookupValue(tmp[key], remainingKeyPath);\n}\n\n/**\n * Some keys should be passed through transparently without normalizing/de-normalizing\n */\nconst noMangleKeys = ['__typename'];\n\n/** Recursively descends the provided object tree and converts all the keys */\nconst convertObjectKeys = (\n  object: object,\n  __converter: RestLink.FieldNameNormalizer,\n  keypath: string[] = [],\n): object => {\n  let converter: RestLink.FieldNameNormalizer = null;\n  if (__converter.length != 2) {\n    converter = (name, keypath) => {\n      return __converter(name);\n    };\n  } else {\n    converter = __converter;\n  }\n\n  if (object == null || typeof object !== 'object') {\n    // Object is a scalar or null / undefined => no keys to convert!\n    return object;\n  }\n\n  // FileList/File are only available in some browser contexts\n  // Notably: *not available* in react-native.\n  if (\n    ((global as any).FileList && object instanceof FileList) ||\n    ((global as any).File && object instanceof File)\n  ) {\n    // Object is a FileList or File object => no keys to convert!\n    return object;\n  }\n\n  if (Array.isArray(object)) {\n    return object.map((o, index) =>\n      convertObjectKeys(o, converter, [...keypath, String(index)]),\n    );\n  }\n\n  return Object.keys(object).reduce((acc: any, key: string) => {\n    let value = object[key];\n\n    if (noMangleKeys.indexOf(key) !== -1) {\n      acc[key] = value;\n      return acc;\n    }\n\n    const nestedKeyPath = [...keypath, key];\n    acc[converter(key, nestedKeyPath)] = convertObjectKeys(\n      value,\n      converter,\n      nestedKeyPath,\n    );\n    return acc;\n  }, {});\n};\n\nconst noOpNameNormalizer: RestLink.FieldNameNormalizer = (name: string) => {\n  return name;\n};\n\n/**\n * Helper that makes sure our headers are of the right type to pass to Fetch\n */\nexport const normalizeHeaders = (\n  headers: RestLink.InitializationHeaders,\n): Headers => {\n  // Make sure that our headers object is of the right type\n  if (headers instanceof Headers) {\n    return headers;\n  } else {\n    return new Headers(headers || {});\n  }\n};\n\n/**\n * Returns a new Headers Group that contains all the headers.\n * - If there are duplicates, they will be in the returned header set multiple times!\n */\nexport const concatHeadersMergePolicy: RestLink.HeadersMergePolicy = (\n  ...headerGroups: Headers[]\n): Headers => {\n  return headerGroups.reduce((accumulator, current) => {\n    if (!current) {\n      return accumulator;\n    }\n    if (!current.forEach) {\n      current = normalizeHeaders(current);\n    }\n    current.forEach((value, key) => {\n      accumulator.append(key, value);\n    });\n\n    return accumulator;\n  }, new Headers());\n};\n\n/**\n * This merge policy deletes any matching headers from the link's default headers.\n * - Pass headersToOverride array & a headers arg to context and this policy will automatically be selected.\n */\nexport const overrideHeadersMergePolicy = (\n  linkHeaders: Headers,\n  headersToOverride: string[],\n  requestHeaders: Headers | null,\n): Headers => {\n  const result = new Headers();\n  linkHeaders.forEach((value, key) => {\n    if (headersToOverride.indexOf(key) !== -1) {\n      return;\n    }\n    result.append(key, value);\n  });\n  return concatHeadersMergePolicy(result, requestHeaders || new Headers());\n};\nexport const overrideHeadersMergePolicyHelper = overrideHeadersMergePolicy; // Deprecated name\n\nconst makeOverrideHeadersMergePolicy = (\n  headersToOverride: string[],\n): RestLink.HeadersMergePolicy => {\n  return (linkHeaders, requestHeaders) => {\n    return overrideHeadersMergePolicy(\n      linkHeaders,\n      headersToOverride,\n      requestHeaders,\n    );\n  };\n};\n\nconst SUPPORTED_HTTP_VERBS = ['GET', 'POST', 'PUT', 'PATCH', 'DELETE'];\n\nexport const validateRequestMethodForOperationType = (\n  method: string,\n  operationType: OperationTypeNode,\n): void => {\n  switch (operationType) {\n    case 'query':\n      if (SUPPORTED_HTTP_VERBS.indexOf(method.toUpperCase()) !== -1) {\n        return;\n      }\n      throw new Error(\n        `A \"query\" operation can only support \"GET\" requests but got \"${method}\".`,\n      );\n    case 'mutation':\n      if (SUPPORTED_HTTP_VERBS.indexOf(method.toUpperCase()) !== -1) {\n        return;\n      }\n      throw new Error('\"mutation\" operations do not support that HTTP-verb');\n    case 'subscription':\n      throw new Error('A \"subscription\" operation is not supported yet.');\n    default:\n      const _exhaustiveCheck: never = operationType;\n      return _exhaustiveCheck;\n  }\n};\n\n/**\n * Utility to build & throw a JS Error from a \"failed\" REST-response\n * @param response: HTTP Response object for this request\n * @param result: Promise that will render the body of the response\n * @param message: Human-facing error message\n */\nconst rethrowServerSideError = (\n  response: Response,\n  result: any,\n  message: string,\n) => {\n  const error = new Error(message) as RestLink.ServerError;\n\n  error.response = response;\n  error.statusCode = response.status;\n  error.result = result;\n\n  throw error;\n};\n\n/** Apollo-Link getContext, provided from the user & mutated by upstream links */\ninterface LinkChainContext {\n  /** Credentials Policy for Fetch */\n  credentials?: RequestCredentials | null;\n\n  /** Headers the user wants to set on this request. See also headersMergePolicy */\n  headers?: RestLink.InitializationHeaders | null;\n\n  /** Will default to concatHeadersMergePolicy unless headersToOverride is set */\n  headersMergePolicy?: RestLink.HeadersMergePolicy | null;\n\n  /** List of headers to override, passing this will swap headersMergePolicy if necessary */\n  headersToOverride?: string[] | null;\n\n  /** An array of the responses from each fetched URL, useful for accessing headers in earlier links */\n  restResponses?: Response[];\n}\n\n/** Context passed via graphql() to our resolver */\ninterface RequestContext {\n  /** Headers the user wants to set on this request. See also headersMergePolicy */\n  headers: Headers;\n\n  /** Credentials Policy for Fetch */\n  credentials?: RequestCredentials | null;\n\n  /** Exported variables fulfilled in this request, using @export(as:). They are stored keyed by node to support deeply nested structures with exports at multiple levels */\n  exportVariablesByNode: Map<any, { [key: string]: any }>;\n\n  endpoints: RestLink.Endpoints;\n  customFetch: RestLink.CustomFetch;\n  operationType: OperationTypeNode;\n  fieldNameNormalizer: RestLink.FieldNameNormalizer;\n  fieldNameDenormalizer: RestLink.FieldNameNormalizer;\n  mainDefinition: OperationDefinitionNode | FragmentDefinitionNode;\n  fragmentDefinitions: FragmentDefinitionNode[];\n  typePatcher: RestLink.FunctionalTypePatcher;\n  serializers: RestLink.Serializers;\n  responseTransformer: RestLink.ResponseTransformer;\n\n  /** An array of the responses from each fetched URL */\n  responses: Response[];\n}\n\nconst addTypeToNode = (node, typename) => {\n  if (node === null || node === undefined || typeof node !== 'object') {\n    return node;\n  }\n\n  if (!Array.isArray(node)) {\n    node['__typename'] = typename;\n    return node;\n  }\n\n  return node.map(item => {\n    return addTypeToNode(item, typename);\n  });\n};\n\nconst resolver: Resolver = async (\n  fieldName: string,\n  root: any,\n  args: any,\n  context: RequestContext,\n  info: ExecInfo,\n) => {\n  const { directives, isLeaf, resultKey } = info;\n  const { exportVariablesByNode } = context;\n\n  const exportVariables = exportVariablesByNode.get(root) || {};\n\n  /** creates a copy of this node's export variables for its child nodes. iterates over array results to provide for each child. returns the passed result. */\n  const copyExportVariables = <T>(result: T): T => {\n    if (result instanceof Array) {\n      result.forEach(copyExportVariables);\n    } else {\n      // export variables are stored keyed on the node they are for\n      exportVariablesByNode.set(result, { ...exportVariables });\n    }\n\n    return result;\n  };\n\n  // Support GraphQL Aliases!\n  const aliasedNode = (root || {})[resultKey];\n  const preAliasingNode = (root || {})[fieldName];\n\n  if (root && directives && directives.export) {\n    // @export(as:) is only supported with apollo-link-rest at this time\n    // so use the preAliasingNode as we're responsible for implementing aliasing!\n    exportVariables[directives.export.as] = preAliasingNode;\n  }\n\n  const isATypeCall = directives && directives.type;\n\n  if (!isLeaf && isATypeCall) {\n    // @type(name: ) is only supported inside apollo-link-rest at this time\n    // so use the preAliasingNode as we're responsible for implementing aliasing!\n    // Also: exit early, since @type(name: ) && @rest() can't both exist on the same node.\n    if (directives.rest) {\n      throw new Error(\n        'Invalid use of @type(name: ...) directive on a call that also has @rest(...)',\n      );\n    }\n    copyExportVariables(preAliasingNode);\n    return addTypeToNode(preAliasingNode, directives.type.name);\n  }\n\n  const isNotARestCall = !directives || !directives.rest;\n  if (isNotARestCall) {\n    // This is not tagged with @rest()\n    // This might not belong to us so return the aliasNode version preferentially\n    return copyExportVariables(aliasedNode || preAliasingNode);\n  }\n  const {\n    credentials,\n    endpoints,\n    headers,\n    customFetch,\n    operationType,\n    typePatcher,\n    mainDefinition,\n    fragmentDefinitions,\n    fieldNameNormalizer,\n    fieldNameDenormalizer: linkLevelNameDenormalizer,\n    serializers,\n    responseTransformer,\n  } = context;\n\n  const fragmentMap = createFragmentMap(fragmentDefinitions);\n\n  let {\n    path,\n    endpoint,\n    pathBuilder,\n  } = directives.rest as RestLink.DirectiveOptions;\n\n  const endpointOption = getEndpointOptions(endpoints, endpoint);\n  const neitherPathsProvided = path == null && pathBuilder == null;\n\n  if (neitherPathsProvided) {\n    throw new Error(\n      `One of (\"path\" | \"pathBuilder\") must be set in the @rest() directive. This request had neither, please add one`,\n    );\n  }\n  if (!pathBuilder) {\n    if (!path.includes(':')) {\n      // Colons are the legacy route, and aren't uri encoded anyhow.\n      pathBuilder = PathBuilder.replacerForPath(path);\n    } else {\n      console.warn(\n        \"Deprecated: '@rest(path:' contains a ':' colon, this format will be removed in future versions\",\n      );\n\n      pathBuilder = ({\n        args,\n        exportVariables,\n      }: RestLink.PathBuilderProps): string => {\n        const legacyArgs = {\n          ...args,\n          ...exportVariables,\n        };\n        const pathWithParams = Object.keys(legacyArgs).reduce(\n          (acc, e) => replaceLegacyParam(acc, e, legacyArgs[e]),\n          path,\n        );\n        if (pathWithParams.includes(':')) {\n          throw new Error(\n            'Missing parameters to run query, specify it in the query params or use ' +\n              'an export directive. (If you need to use \":\" inside a variable string' +\n              ' make sure to encode the variables properly using `encodeURIComponent' +\n              '`. Alternatively see documentation about using pathBuilder.)',\n          );\n        }\n        return pathWithParams;\n      };\n    }\n  }\n  const allParams: RestLink.PathBuilderProps = {\n    args,\n    exportVariables,\n    context,\n    '@rest': directives.rest,\n    replacer: pathBuilder,\n  };\n  const pathWithParams = pathBuilder(allParams);\n\n  let {\n    method,\n    type,\n    bodyBuilder,\n    bodyKey,\n    fieldNameDenormalizer: perRequestNameDenormalizer,\n    bodySerializer,\n  } = directives.rest as RestLink.DirectiveOptions;\n  if (!method) {\n    method = 'GET';\n  }\n  if (!bodyKey) {\n    bodyKey = 'input';\n  }\n\n  let body = undefined;\n  let overrideHeaders: Headers = undefined;\n  if (-1 === ['GET', 'DELETE'].indexOf(method)) {\n    // Prepare our body!\n    if (!bodyBuilder) {\n      // By convention GraphQL recommends mutations having a single argument named \"input\"\n      // https://dev-blog.apollodata.com/designing-graphql-mutations-e09de826ed97\n\n      const maybeBody =\n        allParams.exportVariables[bodyKey] ||\n        (allParams.args && allParams.args[bodyKey]);\n      if (!maybeBody) {\n        throw new Error(\n          `[GraphQL ${method} ${operationType} using a REST call without a body]. No \\`${bodyKey}\\` was detected. Pass bodyKey, or bodyBuilder to the @rest() directive to resolve this.`,\n        );\n      }\n\n      bodyBuilder = (argsWithExport: object) => {\n        return maybeBody;\n      };\n    }\n\n    body = convertObjectKeys(\n      bodyBuilder(allParams),\n      perRequestNameDenormalizer ||\n        linkLevelNameDenormalizer ||\n        noOpNameNormalizer,\n    );\n\n    let serializedBody: RestLink.SerializedBody;\n\n    if (typeof bodySerializer === 'string') {\n      if (!serializers.hasOwnProperty(bodySerializer)) {\n        throw new Error(\n          '\"bodySerializer\" must correspond to configured serializer. ' +\n            `Please make sure to specify a serializer called ${bodySerializer} in the \"bodySerializers\" property of the RestLink.`,\n        );\n      }\n      serializedBody = serializers[bodySerializer](body, headers);\n    } else {\n      serializedBody = bodySerializer\n        ? bodySerializer(body, headers)\n        : serializers[DEFAULT_SERIALIZER_KEY](body, headers);\n    }\n\n    body = serializedBody.body;\n    overrideHeaders = new Headers(serializedBody.headers);\n  }\n\n  validateRequestMethodForOperationType(method, operationType || 'query');\n\n  const requestParams = {\n    method,\n    headers: overrideHeaders || headers,\n    body: body,\n\n    // Only set credentials if they're non-null as some browsers throw an exception:\n    // https://github.com/apollographql/apollo-link-rest/issues/121#issuecomment-396049677\n    ...(credentials ? { credentials } : {}),\n  };\n  const requestUrl = `${endpointOption.uri}${pathWithParams}`;\n\n  const response = await (customFetch || fetch)(requestUrl, requestParams);\n  context.responses.push(response);\n\n  let result;\n  if (response.ok) {\n    if (\n      response.status === 204 ||\n      response.headers.get('Content-Length') === '0'\n    ) {\n      // HTTP-204 means \"no-content\", similarly Content-Length implies the same\n      // This commonly occurs when you POST/PUT to the server, and it acknowledges\n      // success, but doesn't return your Resource.\n      result = {};\n    } else {\n      result = response;\n    }\n  } else if (response.status === 404) {\n    // In a GraphQL context a missing resource should be indicated by\n    // a null value rather than throwing a network error\n    result = null;\n  } else {\n    // Default error handling:\n    // Throw a JSError, that will be available under the\n    // \"Network error\" category in apollo-link-error\n    let parsed: any;\n    // responses need to be cloned as they can only be read once\n    try {\n      parsed = await response.clone().json();\n    } catch (error) {\n      // its not json\n      parsed = await response.clone().text();\n    }\n    rethrowServerSideError(\n      response,\n      parsed,\n      `Response not successful: Received status code ${response.status}`,\n    );\n  }\n\n  const transformer = endpointOption.responseTransformer || responseTransformer;\n  if (transformer) {\n    // A responseTransformer might call something else than json() on the response.\n    try {\n      result = await transformer(result, type);\n    } catch (err) {\n      console.warn('An error occurred in a responseTransformer:');\n      throw err;\n    }\n  } else if (result && result.json) {\n    result = await result.json();\n  }\n\n  if (fieldNameNormalizer !== null) {\n    result = convertObjectKeys(result, fieldNameNormalizer);\n  }\n\n  result = findRestDirectivesThenInsertNullsForOmittedFields(\n    resultKey,\n    result,\n    mainDefinition,\n    fragmentMap,\n    mainDefinition.selectionSet,\n  );\n\n  result = addTypeNameToResult(result, type, typePatcher);\n  return copyExportVariables(result);\n};\n\n/**\n * Default key to use when the @rest directive omits the \"endpoint\" parameter.\n */\nconst DEFAULT_ENDPOINT_KEY = '';\n\n/**\n * Default key to use when the @rest directive omits the \"bodySerializers\" parameter.\n */\nconst DEFAULT_SERIALIZER_KEY = '';\n\nconst DEFAULT_JSON_SERIALIZER: RestLink.Serializer = (\n  data: any,\n  headers: Headers,\n) => {\n  if (!headers.has('content-type')) {\n    headers.append('Content-Type', 'application/json');\n  }\n  return {\n    body: JSON.stringify(data),\n    headers: headers,\n  };\n};\n\nconst CONNECTION_REMOVE_CONFIG = {\n  test: (directive: DirectiveNode) => directive.name.value === 'rest',\n  remove: true,\n};\n\n/**\n * RestLink is an apollo-link for communicating with REST services using GraphQL on the client-side\n */\nexport class RestLink extends ApolloLink {\n  private readonly endpoints: RestLink.Endpoints;\n  private readonly headers: Headers;\n  private readonly fieldNameNormalizer: RestLink.FieldNameNormalizer;\n  private readonly fieldNameDenormalizer: RestLink.FieldNameNormalizer;\n  private readonly typePatcher: RestLink.FunctionalTypePatcher;\n  private readonly credentials: RequestCredentials;\n  private readonly customFetch: RestLink.CustomFetch;\n  private readonly serializers: RestLink.Serializers;\n  private readonly responseTransformer: RestLink.ResponseTransformer;\n  private readonly processedDocuments: Map<DocumentNode, DocumentNode>;\n\n  constructor({\n    uri,\n    endpoints,\n    headers,\n    fieldNameNormalizer,\n    fieldNameDenormalizer,\n    typePatcher,\n    customFetch,\n    credentials,\n    bodySerializers,\n    defaultSerializer,\n    responseTransformer,\n  }: RestLink.Options) {\n    super();\n    const fallback = {};\n    fallback[DEFAULT_ENDPOINT_KEY] = uri || '';\n    this.endpoints = Object.assign({}, endpoints || fallback);\n\n    if (uri == null && endpoints == null) {\n      throw new Error(\n        'A RestLink must be initialized with either 1 uri, or a map of keyed-endpoints',\n      );\n    }\n    if (uri != null) {\n      const currentDefaultURI = (endpoints || {})[DEFAULT_ENDPOINT_KEY];\n      if (currentDefaultURI != null && currentDefaultURI != uri) {\n        throw new Error(\n          \"RestLink was configured with a default uri that doesn't match what's passed in to the endpoints map.\",\n        );\n      }\n      this.endpoints[DEFAULT_ENDPOINT_KEY] = uri;\n    }\n\n    if (this.endpoints[DEFAULT_ENDPOINT_KEY] == null) {\n      console.warn(\n        'RestLink configured without a default URI. All @rest(â€¦) directives must provide an endpoint key!',\n      );\n    }\n\n    if (typePatcher == null) {\n      this.typePatcher = (result, __typename, _2) => {\n        return { __typename, ...result };\n      };\n    } else if (\n      !Array.isArray(typePatcher) &&\n      typeof typePatcher === 'object' &&\n      Object.keys(typePatcher)\n        .map(key => typePatcher[key])\n        .reduce(\n          // Make sure all of the values are patcher-functions\n          (current, patcher) => current && typeof patcher === 'function',\n          true,\n        )\n    ) {\n      const table: RestLink.TypePatcherTable = typePatcher;\n      this.typePatcher = (\n        data: any,\n        outerType: string,\n        patchDeeper: RestLink.FunctionalTypePatcher,\n      ) => {\n        const __typename = data.__typename || outerType;\n        if (Array.isArray(data)) {\n          return data.map(d => patchDeeper(d, __typename, patchDeeper));\n        }\n        const subPatcher = table[__typename] || (result => result);\n        return {\n          __typename,\n          ...subPatcher(data, __typename, patchDeeper),\n        };\n      };\n    } else {\n      throw new Error(\n        'RestLink was configured with a typePatcher of invalid type!',\n      );\n    }\n\n    if (\n      bodySerializers &&\n      bodySerializers.hasOwnProperty(DEFAULT_SERIALIZER_KEY)\n    ) {\n      console.warn(\n        'RestLink was configured to override the default serializer! This may result in unexpected behavior',\n      );\n    }\n\n    this.responseTransformer = responseTransformer || null;\n    this.fieldNameNormalizer = fieldNameNormalizer || null;\n    this.fieldNameDenormalizer = fieldNameDenormalizer || null;\n    this.headers = normalizeHeaders(headers);\n    this.credentials = credentials || null;\n    this.customFetch = customFetch;\n    this.serializers = {\n      [DEFAULT_SERIALIZER_KEY]: defaultSerializer || DEFAULT_JSON_SERIALIZER,\n      ...(bodySerializers || {}),\n    };\n    this.processedDocuments = new Map();\n  }\n\n  private removeRestSetsFromDocument(query: DocumentNode): DocumentNode {\n    const cached = this.processedDocuments.get(query);\n    if (cached) return cached;\n\n    checkDocument(query);\n\n    const docClone = removeDirectivesFromDocument(\n      [CONNECTION_REMOVE_CONFIG],\n      query,\n    );\n\n    this.processedDocuments.set(query, docClone);\n    return docClone;\n  }\n\n  public request(\n    operation: Operation,\n    forward?: NextLink,\n  ): Observable<FetchResult> | null {\n    const { query, variables, getContext, setContext } = operation;\n    const context: LinkChainContext | any = getContext() as any;\n    const isRestQuery = hasDirectives(['rest'], query);\n    if (!isRestQuery) {\n      return forward(operation);\n    }\n\n    const nonRest = this.removeRestSetsFromDocument(query);\n\n    // 1. Use the user's merge policy if any\n    let headersMergePolicy: RestLink.HeadersMergePolicy =\n      context.headersMergePolicy;\n    if (\n      headersMergePolicy == null &&\n      Array.isArray(context.headersToOverride)\n    ) {\n      // 2.a. Override just the passed in headers, if user provided that optional array\n      headersMergePolicy = makeOverrideHeadersMergePolicy(\n        context.headersToOverride,\n      );\n    } else if (headersMergePolicy == null) {\n      // 2.b Glue the link (default) headers to the request-context headers\n      headersMergePolicy = concatHeadersMergePolicy;\n    }\n\n    const headers = headersMergePolicy(this.headers, context.headers);\n    if (!headers.has('Accept')) {\n      // Since we assume a json body on successful responses set the Accept\n      // header accordingly if it is not provided by the user\n      headers.append('Accept', 'application/json');\n    }\n\n    const credentials: RequestCredentials =\n      context.credentials || this.credentials;\n\n    const queryWithTypename = addTypenameToDocument(query);\n\n    const mainDefinition = getMainDefinition(query);\n    const fragmentDefinitions = getFragmentDefinitions(query);\n\n    const operationType: OperationTypeNode =\n      (mainDefinition || ({} as any)).operation || 'query';\n\n    const requestContext: RequestContext = {\n      headers,\n      endpoints: this.endpoints,\n      // Provide an empty map for this request's exports to be stuffed into\n      exportVariablesByNode: new Map(),\n      credentials,\n      customFetch: this.customFetch,\n      operationType,\n      fieldNameNormalizer: this.fieldNameNormalizer,\n      fieldNameDenormalizer: this.fieldNameDenormalizer,\n      mainDefinition,\n      fragmentDefinitions,\n      typePatcher: this.typePatcher,\n      serializers: this.serializers,\n      responses: [],\n      responseTransformer: this.responseTransformer,\n    };\n    const resolverOptions = {};\n    let obs;\n    if (nonRest && forward) {\n      operation.query = nonRest;\n      obs = forward(operation);\n    } else obs = Observable.of({ data: {} });\n\n    return obs.flatMap(\n      ({ data, errors }) =>\n        new Observable(observer => {\n          graphql(\n            resolver,\n            queryWithTypename,\n            data,\n            requestContext,\n            variables,\n            resolverOptions,\n          )\n            .then(data => {\n              setContext({\n                restResponses: (context.restResponses || []).concat(\n                  requestContext.responses,\n                ),\n              });\n              observer.next({ data, errors });\n              observer.complete();\n            })\n            .catch(err => {\n              if (err.name === 'AbortError') return;\n              if (err.result && err.result.errors) {\n                observer.next(err.result);\n              }\n              observer.error(err);\n            });\n        }),\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"script"}