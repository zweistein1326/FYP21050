{"ast":null,"code":"// Depends on jsbn.js and rng.js\n// Version 1.1: support utf-8 encoding in pkcs1pad2\n// convert a (hex) string to a bignum object\nimport { BigInteger, nbi, parseBigInt } from \"./jsbn\";\nimport { SecureRandom } from \"./rng\"; // function linebrk(s,n) {\n//   var ret = \"\";\n//   var i = 0;\n//   while(i + n < s.length) {\n//     ret += s.substring(i,i+n) + \"\\n\";\n//     i += n;\n//   }\n//   return ret + s.substring(i,s.length);\n// }\n// function byte2Hex(b) {\n//   if(b < 0x10)\n//     return \"0\" + b.toString(16);\n//   else\n//     return b.toString(16);\n// }\n\nfunction pkcs1pad1(s, n) {\n  if (n < s.length + 22) {\n    console.error(\"Message too long for RSA\");\n    return null;\n  }\n\n  var len = n - s.length - 6;\n  var filler = \"\";\n\n  for (var f = 0; f < len; f += 2) {\n    filler += \"ff\";\n  }\n\n  var m = \"0001\" + filler + \"00\" + s;\n  return parseBigInt(m, 16);\n} // PKCS#1 (type 2, random) pad input string s to n bytes, and return a bigint\n\n\nfunction pkcs1pad2(s, n) {\n  if (n < s.length + 11) {\n    // TODO: fix for utf-8\n    console.error(\"Message too long for RSA\");\n    return null;\n  }\n\n  var ba = [];\n  var i = s.length - 1;\n\n  while (i >= 0 && n > 0) {\n    var c = s.charCodeAt(i--);\n\n    if (c < 128) {\n      // encode using utf-8\n      ba[--n] = c;\n    } else if (c > 127 && c < 2048) {\n      ba[--n] = c & 63 | 128;\n      ba[--n] = c >> 6 | 192;\n    } else {\n      ba[--n] = c & 63 | 128;\n      ba[--n] = c >> 6 & 63 | 128;\n      ba[--n] = c >> 12 | 224;\n    }\n  }\n\n  ba[--n] = 0;\n  var rng = new SecureRandom();\n  var x = [];\n\n  while (n > 2) {\n    // random non-zero pad\n    x[0] = 0;\n\n    while (x[0] == 0) {\n      rng.nextBytes(x);\n    }\n\n    ba[--n] = x[0];\n  }\n\n  ba[--n] = 2;\n  ba[--n] = 0;\n  return new BigInteger(ba);\n} // \"empty\" RSA key constructor\n\n\nvar RSAKey =\n/** @class */\nfunction () {\n  function RSAKey() {\n    this.n = null;\n    this.e = 0;\n    this.d = null;\n    this.p = null;\n    this.q = null;\n    this.dmp1 = null;\n    this.dmq1 = null;\n    this.coeff = null;\n  } //#region PROTECTED\n  // protected\n  // RSAKey.prototype.doPublic = RSADoPublic;\n  // Perform raw public operation on \"x\": return x^e (mod n)\n\n\n  RSAKey.prototype.doPublic = function (x) {\n    return x.modPowInt(this.e, this.n);\n  }; // RSAKey.prototype.doPrivate = RSADoPrivate;\n  // Perform raw private operation on \"x\": return x^d (mod n)\n\n\n  RSAKey.prototype.doPrivate = function (x) {\n    if (this.p == null || this.q == null) {\n      return x.modPow(this.d, this.n);\n    } // TODO: re-calculate any missing CRT params\n\n\n    var xp = x.mod(this.p).modPow(this.dmp1, this.p);\n    var xq = x.mod(this.q).modPow(this.dmq1, this.q);\n\n    while (xp.compareTo(xq) < 0) {\n      xp = xp.add(this.p);\n    }\n\n    return xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq);\n  }; //#endregion PROTECTED\n  //#region PUBLIC\n  // RSAKey.prototype.setPublic = RSASetPublic;\n  // Set the public key fields N and e from hex strings\n\n\n  RSAKey.prototype.setPublic = function (N, E) {\n    if (N != null && E != null && N.length > 0 && E.length > 0) {\n      this.n = parseBigInt(N, 16);\n      this.e = parseInt(E, 16);\n    } else {\n      console.error(\"Invalid RSA public key\");\n    }\n  }; // RSAKey.prototype.encrypt = RSAEncrypt;\n  // Return the PKCS#1 RSA encryption of \"text\" as an even-length hex string\n\n\n  RSAKey.prototype.encrypt = function (text) {\n    var maxLength = this.n.bitLength() + 7 >> 3;\n    var m = pkcs1pad2(text, maxLength);\n\n    if (m == null) {\n      return null;\n    }\n\n    var c = this.doPublic(m);\n\n    if (c == null) {\n      return null;\n    }\n\n    var h = c.toString(16);\n    var length = h.length; // fix zero before result\n\n    for (var i = 0; i < maxLength * 2 - length; i++) {\n      h = \"0\" + h;\n    }\n\n    return h;\n  }; // RSAKey.prototype.setPrivate = RSASetPrivate;\n  // Set the private key fields N, e, and d from hex strings\n\n\n  RSAKey.prototype.setPrivate = function (N, E, D) {\n    if (N != null && E != null && N.length > 0 && E.length > 0) {\n      this.n = parseBigInt(N, 16);\n      this.e = parseInt(E, 16);\n      this.d = parseBigInt(D, 16);\n    } else {\n      console.error(\"Invalid RSA private key\");\n    }\n  }; // RSAKey.prototype.setPrivateEx = RSASetPrivateEx;\n  // Set the private key fields N, e, d and CRT params from hex strings\n\n\n  RSAKey.prototype.setPrivateEx = function (N, E, D, P, Q, DP, DQ, C) {\n    if (N != null && E != null && N.length > 0 && E.length > 0) {\n      this.n = parseBigInt(N, 16);\n      this.e = parseInt(E, 16);\n      this.d = parseBigInt(D, 16);\n      this.p = parseBigInt(P, 16);\n      this.q = parseBigInt(Q, 16);\n      this.dmp1 = parseBigInt(DP, 16);\n      this.dmq1 = parseBigInt(DQ, 16);\n      this.coeff = parseBigInt(C, 16);\n    } else {\n      console.error(\"Invalid RSA private key\");\n    }\n  }; // RSAKey.prototype.generate = RSAGenerate;\n  // Generate a new random private key B bits long, using public expt E\n\n\n  RSAKey.prototype.generate = function (B, E) {\n    var rng = new SecureRandom();\n    var qs = B >> 1;\n    this.e = parseInt(E, 16);\n    var ee = new BigInteger(E, 16);\n\n    for (;;) {\n      for (;;) {\n        this.p = new BigInteger(B - qs, 1, rng);\n\n        if (this.p.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 && this.p.isProbablePrime(10)) {\n          break;\n        }\n      }\n\n      for (;;) {\n        this.q = new BigInteger(qs, 1, rng);\n\n        if (this.q.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 && this.q.isProbablePrime(10)) {\n          break;\n        }\n      }\n\n      if (this.p.compareTo(this.q) <= 0) {\n        var t = this.p;\n        this.p = this.q;\n        this.q = t;\n      }\n\n      var p1 = this.p.subtract(BigInteger.ONE);\n      var q1 = this.q.subtract(BigInteger.ONE);\n      var phi = p1.multiply(q1);\n\n      if (phi.gcd(ee).compareTo(BigInteger.ONE) == 0) {\n        this.n = this.p.multiply(this.q);\n        this.d = ee.modInverse(phi);\n        this.dmp1 = this.d.mod(p1);\n        this.dmq1 = this.d.mod(q1);\n        this.coeff = this.q.modInverse(this.p);\n        break;\n      }\n    }\n  }; // RSAKey.prototype.decrypt = RSADecrypt;\n  // Return the PKCS#1 RSA decryption of \"ctext\".\n  // \"ctext\" is an even-length hex string and the output is a plain string.\n\n\n  RSAKey.prototype.decrypt = function (ctext) {\n    var c = parseBigInt(ctext, 16);\n    var m = this.doPrivate(c);\n\n    if (m == null) {\n      return null;\n    }\n\n    return pkcs1unpad2(m, this.n.bitLength() + 7 >> 3);\n  }; // Generate a new random private key B bits long, using public expt E\n\n\n  RSAKey.prototype.generateAsync = function (B, E, callback) {\n    var rng = new SecureRandom();\n    var qs = B >> 1;\n    this.e = parseInt(E, 16);\n    var ee = new BigInteger(E, 16);\n    var rsa = this; // These functions have non-descript names because they were originally for(;;) loops.\n    // I don't know about cryptography to give them better names than loop1-4.\n\n    var loop1 = function () {\n      var loop4 = function () {\n        if (rsa.p.compareTo(rsa.q) <= 0) {\n          var t = rsa.p;\n          rsa.p = rsa.q;\n          rsa.q = t;\n        }\n\n        var p1 = rsa.p.subtract(BigInteger.ONE);\n        var q1 = rsa.q.subtract(BigInteger.ONE);\n        var phi = p1.multiply(q1);\n\n        if (phi.gcd(ee).compareTo(BigInteger.ONE) == 0) {\n          rsa.n = rsa.p.multiply(rsa.q);\n          rsa.d = ee.modInverse(phi);\n          rsa.dmp1 = rsa.d.mod(p1);\n          rsa.dmq1 = rsa.d.mod(q1);\n          rsa.coeff = rsa.q.modInverse(rsa.p);\n          setTimeout(function () {\n            callback();\n          }, 0); // escape\n        } else {\n          setTimeout(loop1, 0);\n        }\n      };\n\n      var loop3 = function () {\n        rsa.q = nbi();\n        rsa.q.fromNumberAsync(qs, 1, rng, function () {\n          rsa.q.subtract(BigInteger.ONE).gcda(ee, function (r) {\n            if (r.compareTo(BigInteger.ONE) == 0 && rsa.q.isProbablePrime(10)) {\n              setTimeout(loop4, 0);\n            } else {\n              setTimeout(loop3, 0);\n            }\n          });\n        });\n      };\n\n      var loop2 = function () {\n        rsa.p = nbi();\n        rsa.p.fromNumberAsync(B - qs, 1, rng, function () {\n          rsa.p.subtract(BigInteger.ONE).gcda(ee, function (r) {\n            if (r.compareTo(BigInteger.ONE) == 0 && rsa.p.isProbablePrime(10)) {\n              setTimeout(loop3, 0);\n            } else {\n              setTimeout(loop2, 0);\n            }\n          });\n        });\n      };\n\n      setTimeout(loop2, 0);\n    };\n\n    setTimeout(loop1, 0);\n  };\n\n  RSAKey.prototype.sign = function (text, digestMethod, digestName) {\n    var header = getDigestHeader(digestName);\n    var digest = header + digestMethod(text).toString();\n    var m = pkcs1pad1(digest, this.n.bitLength() / 4);\n\n    if (m == null) {\n      return null;\n    }\n\n    var c = this.doPrivate(m);\n\n    if (c == null) {\n      return null;\n    }\n\n    var h = c.toString(16);\n\n    if ((h.length & 1) == 0) {\n      return h;\n    } else {\n      return \"0\" + h;\n    }\n  };\n\n  RSAKey.prototype.verify = function (text, signature, digestMethod) {\n    var c = parseBigInt(signature, 16);\n    var m = this.doPublic(c);\n\n    if (m == null) {\n      return null;\n    }\n\n    var unpadded = m.toString(16).replace(/^1f+00/, \"\");\n    var digest = removeDigestHeader(unpadded);\n    return digest == digestMethod(text).toString();\n  };\n\n  return RSAKey;\n}();\n\nexport { RSAKey }; // Undo PKCS#1 (type 2, random) padding and, if valid, return the plaintext\n\nfunction pkcs1unpad2(d, n) {\n  var b = d.toByteArray();\n  var i = 0;\n\n  while (i < b.length && b[i] == 0) {\n    ++i;\n  }\n\n  if (b.length - i != n - 1 || b[i] != 2) {\n    return null;\n  }\n\n  ++i;\n\n  while (b[i] != 0) {\n    if (++i >= b.length) {\n      return null;\n    }\n  }\n\n  var ret = \"\";\n\n  while (++i < b.length) {\n    var c = b[i] & 255;\n\n    if (c < 128) {\n      // utf-8 decode\n      ret += String.fromCharCode(c);\n    } else if (c > 191 && c < 224) {\n      ret += String.fromCharCode((c & 31) << 6 | b[i + 1] & 63);\n      ++i;\n    } else {\n      ret += String.fromCharCode((c & 15) << 12 | (b[i + 1] & 63) << 6 | b[i + 2] & 63);\n      i += 2;\n    }\n  }\n\n  return ret;\n} // https://tools.ietf.org/html/rfc3447#page-43\n\n\nvar DIGEST_HEADERS = {\n  md2: \"3020300c06082a864886f70d020205000410\",\n  md5: \"3020300c06082a864886f70d020505000410\",\n  sha1: \"3021300906052b0e03021a05000414\",\n  sha224: \"302d300d06096086480165030402040500041c\",\n  sha256: \"3031300d060960864801650304020105000420\",\n  sha384: \"3041300d060960864801650304020205000430\",\n  sha512: \"3051300d060960864801650304020305000440\",\n  ripemd160: \"3021300906052b2403020105000414\"\n};\n\nfunction getDigestHeader(name) {\n  return DIGEST_HEADERS[name] || \"\";\n}\n\nfunction removeDigestHeader(str) {\n  for (var name_1 in DIGEST_HEADERS) {\n    if (DIGEST_HEADERS.hasOwnProperty(name_1)) {\n      var header = DIGEST_HEADERS[name_1];\n      var len = header.length;\n\n      if (str.substr(0, len) == header) {\n        return str.substr(len);\n      }\n    }\n  }\n\n  return str;\n} // Return the PKCS#1 RSA encryption of \"text\" as a Base64-encoded string\n// function RSAEncryptB64(text) {\n//  var h = this.encrypt(text);\n//  if(h) return hex2b64(h); else return null;\n// }\n// public\n// RSAKey.prototype.encrypt_b64 = RSAEncryptB64;","map":{"version":3,"sources":["/Users/sid/Desktop/SSOB/sso/client/node_modules/jsencrypt/lib/lib/jsbn/rsa.js"],"names":["BigInteger","nbi","parseBigInt","SecureRandom","pkcs1pad1","s","n","length","console","error","len","filler","f","m","pkcs1pad2","ba","i","c","charCodeAt","rng","x","nextBytes","RSAKey","e","d","p","q","dmp1","dmq1","coeff","prototype","doPublic","modPowInt","doPrivate","modPow","xp","mod","xq","compareTo","add","subtract","multiply","setPublic","N","E","parseInt","encrypt","text","maxLength","bitLength","h","toString","setPrivate","D","setPrivateEx","P","Q","DP","DQ","C","generate","B","qs","ee","ONE","gcd","isProbablePrime","t","p1","q1","phi","modInverse","decrypt","ctext","pkcs1unpad2","generateAsync","callback","rsa","loop1","loop4","setTimeout","loop3","fromNumberAsync","gcda","r","loop2","sign","digestMethod","digestName","header","getDigestHeader","digest","verify","signature","unpadded","replace","removeDigestHeader","b","toByteArray","ret","String","fromCharCode","DIGEST_HEADERS","md2","md5","sha1","sha224","sha256","sha384","sha512","ripemd160","name","str","name_1","hasOwnProperty","substr"],"mappings":"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","sourcesContent":["// Depends on jsbn.js and rng.js\n// Version 1.1: support utf-8 encoding in pkcs1pad2\n// convert a (hex) string to a bignum object\nimport { BigInteger, nbi, parseBigInt } from \"./jsbn\";\nimport { SecureRandom } from \"./rng\";\n// function linebrk(s,n) {\n//   var ret = \"\";\n//   var i = 0;\n//   while(i + n < s.length) {\n//     ret += s.substring(i,i+n) + \"\\n\";\n//     i += n;\n//   }\n//   return ret + s.substring(i,s.length);\n// }\n// function byte2Hex(b) {\n//   if(b < 0x10)\n//     return \"0\" + b.toString(16);\n//   else\n//     return b.toString(16);\n// }\nfunction pkcs1pad1(s, n) {\n    if (n < s.length + 22) {\n        console.error(\"Message too long for RSA\");\n        return null;\n    }\n    var len = n - s.length - 6;\n    var filler = \"\";\n    for (var f = 0; f < len; f += 2) {\n        filler += \"ff\";\n    }\n    var m = \"0001\" + filler + \"00\" + s;\n    return parseBigInt(m, 16);\n}\n// PKCS#1 (type 2, random) pad input string s to n bytes, and return a bigint\nfunction pkcs1pad2(s, n) {\n    if (n < s.length + 11) { // TODO: fix for utf-8\n        console.error(\"Message too long for RSA\");\n        return null;\n    }\n    var ba = [];\n    var i = s.length - 1;\n    while (i >= 0 && n > 0) {\n        var c = s.charCodeAt(i--);\n        if (c < 128) { // encode using utf-8\n            ba[--n] = c;\n        }\n        else if ((c > 127) && (c < 2048)) {\n            ba[--n] = (c & 63) | 128;\n            ba[--n] = (c >> 6) | 192;\n        }\n        else {\n            ba[--n] = (c & 63) | 128;\n            ba[--n] = ((c >> 6) & 63) | 128;\n            ba[--n] = (c >> 12) | 224;\n        }\n    }\n    ba[--n] = 0;\n    var rng = new SecureRandom();\n    var x = [];\n    while (n > 2) { // random non-zero pad\n        x[0] = 0;\n        while (x[0] == 0) {\n            rng.nextBytes(x);\n        }\n        ba[--n] = x[0];\n    }\n    ba[--n] = 2;\n    ba[--n] = 0;\n    return new BigInteger(ba);\n}\n// \"empty\" RSA key constructor\nvar RSAKey = /** @class */ (function () {\n    function RSAKey() {\n        this.n = null;\n        this.e = 0;\n        this.d = null;\n        this.p = null;\n        this.q = null;\n        this.dmp1 = null;\n        this.dmq1 = null;\n        this.coeff = null;\n    }\n    //#region PROTECTED\n    // protected\n    // RSAKey.prototype.doPublic = RSADoPublic;\n    // Perform raw public operation on \"x\": return x^e (mod n)\n    RSAKey.prototype.doPublic = function (x) {\n        return x.modPowInt(this.e, this.n);\n    };\n    // RSAKey.prototype.doPrivate = RSADoPrivate;\n    // Perform raw private operation on \"x\": return x^d (mod n)\n    RSAKey.prototype.doPrivate = function (x) {\n        if (this.p == null || this.q == null) {\n            return x.modPow(this.d, this.n);\n        }\n        // TODO: re-calculate any missing CRT params\n        var xp = x.mod(this.p).modPow(this.dmp1, this.p);\n        var xq = x.mod(this.q).modPow(this.dmq1, this.q);\n        while (xp.compareTo(xq) < 0) {\n            xp = xp.add(this.p);\n        }\n        return xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq);\n    };\n    //#endregion PROTECTED\n    //#region PUBLIC\n    // RSAKey.prototype.setPublic = RSASetPublic;\n    // Set the public key fields N and e from hex strings\n    RSAKey.prototype.setPublic = function (N, E) {\n        if (N != null && E != null && N.length > 0 && E.length > 0) {\n            this.n = parseBigInt(N, 16);\n            this.e = parseInt(E, 16);\n        }\n        else {\n            console.error(\"Invalid RSA public key\");\n        }\n    };\n    // RSAKey.prototype.encrypt = RSAEncrypt;\n    // Return the PKCS#1 RSA encryption of \"text\" as an even-length hex string\n    RSAKey.prototype.encrypt = function (text) {\n        var maxLength = (this.n.bitLength() + 7) >> 3;\n        var m = pkcs1pad2(text, maxLength);\n        if (m == null) {\n            return null;\n        }\n        var c = this.doPublic(m);\n        if (c == null) {\n            return null;\n        }\n        var h = c.toString(16);\n        var length = h.length;\n        // fix zero before result\n        for (var i = 0; i < maxLength * 2 - length; i++) {\n            h = \"0\" + h;\n        }\n        return h;\n    };\n    // RSAKey.prototype.setPrivate = RSASetPrivate;\n    // Set the private key fields N, e, and d from hex strings\n    RSAKey.prototype.setPrivate = function (N, E, D) {\n        if (N != null && E != null && N.length > 0 && E.length > 0) {\n            this.n = parseBigInt(N, 16);\n            this.e = parseInt(E, 16);\n            this.d = parseBigInt(D, 16);\n        }\n        else {\n            console.error(\"Invalid RSA private key\");\n        }\n    };\n    // RSAKey.prototype.setPrivateEx = RSASetPrivateEx;\n    // Set the private key fields N, e, d and CRT params from hex strings\n    RSAKey.prototype.setPrivateEx = function (N, E, D, P, Q, DP, DQ, C) {\n        if (N != null && E != null && N.length > 0 && E.length > 0) {\n            this.n = parseBigInt(N, 16);\n            this.e = parseInt(E, 16);\n            this.d = parseBigInt(D, 16);\n            this.p = parseBigInt(P, 16);\n            this.q = parseBigInt(Q, 16);\n            this.dmp1 = parseBigInt(DP, 16);\n            this.dmq1 = parseBigInt(DQ, 16);\n            this.coeff = parseBigInt(C, 16);\n        }\n        else {\n            console.error(\"Invalid RSA private key\");\n        }\n    };\n    // RSAKey.prototype.generate = RSAGenerate;\n    // Generate a new random private key B bits long, using public expt E\n    RSAKey.prototype.generate = function (B, E) {\n        var rng = new SecureRandom();\n        var qs = B >> 1;\n        this.e = parseInt(E, 16);\n        var ee = new BigInteger(E, 16);\n        for (;;) {\n            for (;;) {\n                this.p = new BigInteger(B - qs, 1, rng);\n                if (this.p.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 && this.p.isProbablePrime(10)) {\n                    break;\n                }\n            }\n            for (;;) {\n                this.q = new BigInteger(qs, 1, rng);\n                if (this.q.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 && this.q.isProbablePrime(10)) {\n                    break;\n                }\n            }\n            if (this.p.compareTo(this.q) <= 0) {\n                var t = this.p;\n                this.p = this.q;\n                this.q = t;\n            }\n            var p1 = this.p.subtract(BigInteger.ONE);\n            var q1 = this.q.subtract(BigInteger.ONE);\n            var phi = p1.multiply(q1);\n            if (phi.gcd(ee).compareTo(BigInteger.ONE) == 0) {\n                this.n = this.p.multiply(this.q);\n                this.d = ee.modInverse(phi);\n                this.dmp1 = this.d.mod(p1);\n                this.dmq1 = this.d.mod(q1);\n                this.coeff = this.q.modInverse(this.p);\n                break;\n            }\n        }\n    };\n    // RSAKey.prototype.decrypt = RSADecrypt;\n    // Return the PKCS#1 RSA decryption of \"ctext\".\n    // \"ctext\" is an even-length hex string and the output is a plain string.\n    RSAKey.prototype.decrypt = function (ctext) {\n        var c = parseBigInt(ctext, 16);\n        var m = this.doPrivate(c);\n        if (m == null) {\n            return null;\n        }\n        return pkcs1unpad2(m, (this.n.bitLength() + 7) >> 3);\n    };\n    // Generate a new random private key B bits long, using public expt E\n    RSAKey.prototype.generateAsync = function (B, E, callback) {\n        var rng = new SecureRandom();\n        var qs = B >> 1;\n        this.e = parseInt(E, 16);\n        var ee = new BigInteger(E, 16);\n        var rsa = this;\n        // These functions have non-descript names because they were originally for(;;) loops.\n        // I don't know about cryptography to give them better names than loop1-4.\n        var loop1 = function () {\n            var loop4 = function () {\n                if (rsa.p.compareTo(rsa.q) <= 0) {\n                    var t = rsa.p;\n                    rsa.p = rsa.q;\n                    rsa.q = t;\n                }\n                var p1 = rsa.p.subtract(BigInteger.ONE);\n                var q1 = rsa.q.subtract(BigInteger.ONE);\n                var phi = p1.multiply(q1);\n                if (phi.gcd(ee).compareTo(BigInteger.ONE) == 0) {\n                    rsa.n = rsa.p.multiply(rsa.q);\n                    rsa.d = ee.modInverse(phi);\n                    rsa.dmp1 = rsa.d.mod(p1);\n                    rsa.dmq1 = rsa.d.mod(q1);\n                    rsa.coeff = rsa.q.modInverse(rsa.p);\n                    setTimeout(function () { callback(); }, 0); // escape\n                }\n                else {\n                    setTimeout(loop1, 0);\n                }\n            };\n            var loop3 = function () {\n                rsa.q = nbi();\n                rsa.q.fromNumberAsync(qs, 1, rng, function () {\n                    rsa.q.subtract(BigInteger.ONE).gcda(ee, function (r) {\n                        if (r.compareTo(BigInteger.ONE) == 0 && rsa.q.isProbablePrime(10)) {\n                            setTimeout(loop4, 0);\n                        }\n                        else {\n                            setTimeout(loop3, 0);\n                        }\n                    });\n                });\n            };\n            var loop2 = function () {\n                rsa.p = nbi();\n                rsa.p.fromNumberAsync(B - qs, 1, rng, function () {\n                    rsa.p.subtract(BigInteger.ONE).gcda(ee, function (r) {\n                        if (r.compareTo(BigInteger.ONE) == 0 && rsa.p.isProbablePrime(10)) {\n                            setTimeout(loop3, 0);\n                        }\n                        else {\n                            setTimeout(loop2, 0);\n                        }\n                    });\n                });\n            };\n            setTimeout(loop2, 0);\n        };\n        setTimeout(loop1, 0);\n    };\n    RSAKey.prototype.sign = function (text, digestMethod, digestName) {\n        var header = getDigestHeader(digestName);\n        var digest = header + digestMethod(text).toString();\n        var m = pkcs1pad1(digest, this.n.bitLength() / 4);\n        if (m == null) {\n            return null;\n        }\n        var c = this.doPrivate(m);\n        if (c == null) {\n            return null;\n        }\n        var h = c.toString(16);\n        if ((h.length & 1) == 0) {\n            return h;\n        }\n        else {\n            return \"0\" + h;\n        }\n    };\n    RSAKey.prototype.verify = function (text, signature, digestMethod) {\n        var c = parseBigInt(signature, 16);\n        var m = this.doPublic(c);\n        if (m == null) {\n            return null;\n        }\n        var unpadded = m.toString(16).replace(/^1f+00/, \"\");\n        var digest = removeDigestHeader(unpadded);\n        return digest == digestMethod(text).toString();\n    };\n    return RSAKey;\n}());\nexport { RSAKey };\n// Undo PKCS#1 (type 2, random) padding and, if valid, return the plaintext\nfunction pkcs1unpad2(d, n) {\n    var b = d.toByteArray();\n    var i = 0;\n    while (i < b.length && b[i] == 0) {\n        ++i;\n    }\n    if (b.length - i != n - 1 || b[i] != 2) {\n        return null;\n    }\n    ++i;\n    while (b[i] != 0) {\n        if (++i >= b.length) {\n            return null;\n        }\n    }\n    var ret = \"\";\n    while (++i < b.length) {\n        var c = b[i] & 255;\n        if (c < 128) { // utf-8 decode\n            ret += String.fromCharCode(c);\n        }\n        else if ((c > 191) && (c < 224)) {\n            ret += String.fromCharCode(((c & 31) << 6) | (b[i + 1] & 63));\n            ++i;\n        }\n        else {\n            ret += String.fromCharCode(((c & 15) << 12) | ((b[i + 1] & 63) << 6) | (b[i + 2] & 63));\n            i += 2;\n        }\n    }\n    return ret;\n}\n// https://tools.ietf.org/html/rfc3447#page-43\nvar DIGEST_HEADERS = {\n    md2: \"3020300c06082a864886f70d020205000410\",\n    md5: \"3020300c06082a864886f70d020505000410\",\n    sha1: \"3021300906052b0e03021a05000414\",\n    sha224: \"302d300d06096086480165030402040500041c\",\n    sha256: \"3031300d060960864801650304020105000420\",\n    sha384: \"3041300d060960864801650304020205000430\",\n    sha512: \"3051300d060960864801650304020305000440\",\n    ripemd160: \"3021300906052b2403020105000414\"\n};\nfunction getDigestHeader(name) {\n    return DIGEST_HEADERS[name] || \"\";\n}\nfunction removeDigestHeader(str) {\n    for (var name_1 in DIGEST_HEADERS) {\n        if (DIGEST_HEADERS.hasOwnProperty(name_1)) {\n            var header = DIGEST_HEADERS[name_1];\n            var len = header.length;\n            if (str.substr(0, len) == header) {\n                return str.substr(len);\n            }\n        }\n    }\n    return str;\n}\n// Return the PKCS#1 RSA encryption of \"text\" as a Base64-encoded string\n// function RSAEncryptB64(text) {\n//  var h = this.encrypt(text);\n//  if(h) return hex2b64(h); else return null;\n// }\n// public\n// RSAKey.prototype.encrypt_b64 = RSAEncryptB64;\n"]},"metadata":{},"sourceType":"module"}