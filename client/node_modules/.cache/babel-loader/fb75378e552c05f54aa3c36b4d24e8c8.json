{"ast":null,"code":"/* eslint linebreak-style: [\"error\", \"windows\"] */\n\n/* eslint-disable no-use-before-define */\nimport Base from './Base.js';\nimport Utf8 from './Utf8.js';\n/**\r\n * HMAC algorithm.\r\n */\n\nexport default class HMAC extends Base {\n  /**\r\n     * Initializes a newly created HMAC.\r\n     *\r\n     * @param {Hasher} SubHasher The hash algorithm to use.\r\n     * @param {WordArray|string} key The secret key.\r\n     *\r\n     * @example\r\n     *\r\n     *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);\r\n     */\n  constructor(SubHasher, key) {\n    super();\n    const hasher = new SubHasher();\n    this._hasher = hasher; // Convert string to WordArray, else assume WordArray already\n\n    let _key = key;\n\n    if (typeof _key === 'string') {\n      _key = Utf8.parse(_key);\n    } // Shortcuts\n\n\n    const hasherBlockSize = hasher.blockSize;\n    const hasherBlockSizeBytes = hasherBlockSize * 4; // Allow arbitrary length keys\n\n    if (_key.sigBytes > hasherBlockSizeBytes) {\n      _key = hasher.finalize(key);\n    } // Clamp excess bits\n\n\n    _key.clamp(); // Clone key for inner and outer pads\n\n\n    const oKey = _key.clone();\n\n    this._oKey = oKey;\n\n    const iKey = _key.clone();\n\n    this._iKey = iKey; // Shortcuts\n\n    const oKeyWords = oKey.words;\n    const iKeyWords = iKey.words; // XOR keys with pad constants\n\n    for (let i = 0; i < hasherBlockSize; i += 1) {\n      oKeyWords[i] ^= 0x5c5c5c5c;\n      iKeyWords[i] ^= 0x36363636;\n    }\n\n    oKey.sigBytes = hasherBlockSizeBytes;\n    iKey.sigBytes = hasherBlockSizeBytes; // Set initial values\n\n    this.reset();\n  }\n  /**\r\n     * Resets this HMAC to its initial state.\r\n     *\r\n     * @example\r\n     *\r\n     *     hmacHasher.reset();\r\n     */\n\n\n  reset() {\n    // Shortcut\n    const hasher = this._hasher; // Reset\n\n    hasher.reset();\n    hasher.update(this._iKey);\n  }\n  /**\r\n     * Updates this HMAC with a message.\r\n     *\r\n     * @param {WordArray|string} messageUpdate The message to append.\r\n     *\r\n     * @return {HMAC} This HMAC instance.\r\n     *\r\n     * @example\r\n     *\r\n     *     hmacHasher.update('message');\r\n     *     hmacHasher.update(wordArray);\r\n     */\n\n\n  update(messageUpdate) {\n    this._hasher.update(messageUpdate); // Chainable\n\n\n    return this;\n  }\n  /**\r\n     * Finalizes the HMAC computation.\r\n     * Note that the finalize operation is effectively a destructive, read-once operation.\r\n     *\r\n     * @param {WordArray|string} messageUpdate (Optional) A final message update.\r\n     *\r\n     * @return {WordArray} The HMAC.\r\n     *\r\n     * @example\r\n     *\r\n     *     var hmac = hmacHasher.finalize();\r\n     *     var hmac = hmacHasher.finalize('message');\r\n     *     var hmac = hmacHasher.finalize(wordArray);\r\n     */\n\n\n  finalize(messageUpdate) {\n    // Shortcut\n    const hasher = this._hasher; // Compute HMAC\n\n    const innerHash = hasher.finalize(messageUpdate);\n    hasher.reset();\n    const hmac = hasher.finalize(this._oKey.clone().concat(innerHash));\n    return hmac;\n  }\n\n}","map":{"version":3,"sources":["/Users/sid/Desktop/SSOB/sso/client/node_modules/react-native-hash/JSHash/lib/core/HMAC.js"],"names":["Base","Utf8","HMAC","constructor","SubHasher","key","hasher","_hasher","_key","parse","hasherBlockSize","blockSize","hasherBlockSizeBytes","sigBytes","finalize","clamp","oKey","clone","_oKey","iKey","_iKey","oKeyWords","words","iKeyWords","i","reset","update","messageUpdate","innerHash","hmac","concat"],"mappings":"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","sourcesContent":["/* eslint linebreak-style: [\"error\", \"windows\"] */\r\n/* eslint-disable no-use-before-define */\r\n\r\nimport Base from './Base.js';\r\nimport Utf8 from './Utf8.js';\r\n\r\n/**\r\n * HMAC algorithm.\r\n */\r\nexport default class HMAC extends Base {\r\n  /**\r\n     * Initializes a newly created HMAC.\r\n     *\r\n     * @param {Hasher} SubHasher The hash algorithm to use.\r\n     * @param {WordArray|string} key The secret key.\r\n     *\r\n     * @example\r\n     *\r\n     *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);\r\n     */\r\n  constructor(SubHasher, key) {\r\n    super();\r\n\r\n    const hasher = new SubHasher();\r\n    this._hasher = hasher;\r\n\r\n    // Convert string to WordArray, else assume WordArray already\r\n    let _key = key;\r\n    if (typeof _key === 'string') {\r\n      _key = Utf8.parse(_key);\r\n    }\r\n\r\n    // Shortcuts\r\n    const hasherBlockSize = hasher.blockSize;\r\n    const hasherBlockSizeBytes = hasherBlockSize * 4;\r\n\r\n    // Allow arbitrary length keys\r\n    if (_key.sigBytes > hasherBlockSizeBytes) {\r\n      _key = hasher.finalize(key);\r\n    }\r\n\r\n    // Clamp excess bits\r\n    _key.clamp();\r\n\r\n    // Clone key for inner and outer pads\r\n    const oKey = _key.clone();\r\n    this._oKey = oKey;\r\n    const iKey = _key.clone();\r\n    this._iKey = iKey;\r\n\r\n    // Shortcuts\r\n    const oKeyWords = oKey.words;\r\n    const iKeyWords = iKey.words;\r\n\r\n    // XOR keys with pad constants\r\n    for (let i = 0; i < hasherBlockSize; i += 1) {\r\n      oKeyWords[i] ^= 0x5c5c5c5c;\r\n      iKeyWords[i] ^= 0x36363636;\r\n    }\r\n    oKey.sigBytes = hasherBlockSizeBytes;\r\n    iKey.sigBytes = hasherBlockSizeBytes;\r\n\r\n    // Set initial values\r\n    this.reset();\r\n  }\r\n\r\n  /**\r\n     * Resets this HMAC to its initial state.\r\n     *\r\n     * @example\r\n     *\r\n     *     hmacHasher.reset();\r\n     */\r\n  reset() {\r\n    // Shortcut\r\n    const hasher = this._hasher;\r\n\r\n    // Reset\r\n    hasher.reset();\r\n    hasher.update(this._iKey);\r\n  }\r\n\r\n  /**\r\n     * Updates this HMAC with a message.\r\n     *\r\n     * @param {WordArray|string} messageUpdate The message to append.\r\n     *\r\n     * @return {HMAC} This HMAC instance.\r\n     *\r\n     * @example\r\n     *\r\n     *     hmacHasher.update('message');\r\n     *     hmacHasher.update(wordArray);\r\n     */\r\n  update(messageUpdate) {\r\n    this._hasher.update(messageUpdate);\r\n\r\n    // Chainable\r\n    return this;\r\n  }\r\n\r\n  /**\r\n     * Finalizes the HMAC computation.\r\n     * Note that the finalize operation is effectively a destructive, read-once operation.\r\n     *\r\n     * @param {WordArray|string} messageUpdate (Optional) A final message update.\r\n     *\r\n     * @return {WordArray} The HMAC.\r\n     *\r\n     * @example\r\n     *\r\n     *     var hmac = hmacHasher.finalize();\r\n     *     var hmac = hmacHasher.finalize('message');\r\n     *     var hmac = hmacHasher.finalize(wordArray);\r\n     */\r\n  finalize(messageUpdate) {\r\n    // Shortcut\r\n    const hasher = this._hasher;\r\n\r\n    // Compute HMAC\r\n    const innerHash = hasher.finalize(messageUpdate);\r\n    hasher.reset();\r\n    const hmac = hasher.finalize(this._oKey.clone().concat(innerHash));\r\n\r\n    return hmac;\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}