{"ast":null,"code":"/* eslint linebreak-style: [\"error\", \"windows\"] */\n\n/* eslint-disable no-use-before-define */\nimport Base from './Base.js';\nimport WordArray from './WordArray.js';\nimport Utf8 from './Utf8.js';\n/**\r\n * Abstract buffered block algorithm template.\r\n *\r\n * The property blockSize must be implemented in a concrete subtype.\r\n *\r\n * @property {number} _minBufferSize\r\n *\r\n *     The number of blocks that should be kept unprocessed in the buffer. Default: 0\r\n */\n\nexport default class BufferedBlockAlgorithm extends Base {\n  constructor() {\n    super();\n    this._minBufferSize = 0;\n  }\n  /**\r\n     * Resets this block algorithm's data buffer to its initial state.\r\n     *\r\n     * @example\r\n     *\r\n     *     bufferedBlockAlgorithm.reset();\r\n     */\n\n\n  reset() {\n    // Initial values\n    this._data = new WordArray();\n    this._nDataBytes = 0;\n  }\n  /**\r\n     * Adds new data to this block algorithm's buffer.\r\n     *\r\n     * @param {WordArray|string} data\r\n     *\r\n     *     The data to append. Strings are converted to a WordArray using UTF-8.\r\n     *\r\n     * @example\r\n     *\r\n     *     bufferedBlockAlgorithm._append('data');\r\n     *     bufferedBlockAlgorithm._append(wordArray);\r\n     */\n\n\n  _append(data) {\n    let m_data = data; // Convert string to WordArray, else assume WordArray already\n\n    if (typeof m_data === 'string') {\n      m_data = Utf8.parse(m_data);\n    } // Append\n\n\n    this._data.concat(m_data);\n\n    this._nDataBytes += m_data.sigBytes;\n  }\n  /**\r\n     * Processes available data blocks.\r\n     *\r\n     * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\r\n     *\r\n     * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.\r\n     *\r\n     * @return {WordArray} The processed data.\r\n     *\r\n     * @example\r\n     *\r\n     *     var processedData = bufferedBlockAlgorithm._process();\r\n     *     var processedData = bufferedBlockAlgorithm._process(!!'flush');\r\n     */\n\n\n  _process(doFlush) {\n    let processedWords; // Shortcuts\n\n    const {\n      _data: data,\n      blockSize\n    } = this;\n    const dataWords = data.words;\n    const dataSigBytes = data.sigBytes;\n    const blockSizeBytes = blockSize * 4; // Count blocks ready\n\n    let nBlocksReady = dataSigBytes / blockSizeBytes;\n\n    if (doFlush) {\n      // Round up to include partial blocks\n      nBlocksReady = Math.ceil(nBlocksReady);\n    } else {\n      // Round down to include only full blocks,\n      // less the number of blocks that must remain in the buffer\n      nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n    } // Count words ready\n\n\n    const nWordsReady = nBlocksReady * blockSize; // Count bytes ready\n\n    const nBytesReady = Math.min(nWordsReady * 4, dataSigBytes); // Process blocks\n\n    if (nWordsReady) {\n      for (let offset = 0; offset < nWordsReady; offset += blockSize) {\n        // Perform concrete-algorithm logic\n        this._doProcessBlock(dataWords, offset);\n      } // Remove processed words\n\n\n      processedWords = dataWords.splice(0, nWordsReady);\n      data.sigBytes -= nBytesReady;\n    } // Return processed words\n\n\n    return new WordArray(processedWords, nBytesReady);\n  }\n  /**\r\n     * Creates a copy of this object.\r\n     *\r\n     * @return {Object} The clone.\r\n     *\r\n     * @example\r\n     *\r\n     *     var clone = bufferedBlockAlgorithm.clone();\r\n     */\n\n\n  clone() {\n    const clone = super.clone.call(this);\n    clone._data = this._data.clone();\n    return clone;\n  }\n\n}","map":{"version":3,"sources":["/Users/sid/Desktop/SSOB/sso/client/node_modules/react-native-hash/JSHash/lib/core/BufferedBlockAlgorithm.js"],"names":["Base","WordArray","Utf8","BufferedBlockAlgorithm","constructor","_minBufferSize","reset","_data","_nDataBytes","_append","data","m_data","parse","concat","sigBytes","_process","doFlush","processedWords","blockSize","dataWords","words","dataSigBytes","blockSizeBytes","nBlocksReady","Math","ceil","max","nWordsReady","nBytesReady","min","offset","_doProcessBlock","splice","clone","call"],"mappings":"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","sourcesContent":["\r\n/* eslint linebreak-style: [\"error\", \"windows\"] */\r\n/* eslint-disable no-use-before-define */\r\n\r\nimport Base from './Base.js';\r\nimport WordArray from './WordArray.js';\r\nimport Utf8 from './Utf8.js';\r\n\r\n/**\r\n * Abstract buffered block algorithm template.\r\n *\r\n * The property blockSize must be implemented in a concrete subtype.\r\n *\r\n * @property {number} _minBufferSize\r\n *\r\n *     The number of blocks that should be kept unprocessed in the buffer. Default: 0\r\n */\r\nexport default class BufferedBlockAlgorithm extends Base {\r\n  constructor() {\r\n    super();\r\n    this._minBufferSize = 0;\r\n  }\r\n\r\n  /**\r\n     * Resets this block algorithm's data buffer to its initial state.\r\n     *\r\n     * @example\r\n     *\r\n     *     bufferedBlockAlgorithm.reset();\r\n     */\r\n  reset() {\r\n    // Initial values\r\n    this._data = new WordArray();\r\n    this._nDataBytes = 0;\r\n  }\r\n\r\n  /**\r\n     * Adds new data to this block algorithm's buffer.\r\n     *\r\n     * @param {WordArray|string} data\r\n     *\r\n     *     The data to append. Strings are converted to a WordArray using UTF-8.\r\n     *\r\n     * @example\r\n     *\r\n     *     bufferedBlockAlgorithm._append('data');\r\n     *     bufferedBlockAlgorithm._append(wordArray);\r\n     */\r\n  _append(data) {\r\n    let m_data = data;\r\n\r\n    // Convert string to WordArray, else assume WordArray already\r\n    if (typeof m_data === 'string') {\r\n      m_data = Utf8.parse(m_data);\r\n    }\r\n\r\n    // Append\r\n    this._data.concat(m_data);\r\n    this._nDataBytes += m_data.sigBytes;\r\n  }\r\n\r\n  /**\r\n     * Processes available data blocks.\r\n     *\r\n     * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\r\n     *\r\n     * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.\r\n     *\r\n     * @return {WordArray} The processed data.\r\n     *\r\n     * @example\r\n     *\r\n     *     var processedData = bufferedBlockAlgorithm._process();\r\n     *     var processedData = bufferedBlockAlgorithm._process(!!'flush');\r\n     */\r\n  _process(doFlush) {\r\n    let processedWords;\r\n\r\n    // Shortcuts\r\n    const { _data: data, blockSize } = this;\r\n    const dataWords = data.words;\r\n    const dataSigBytes = data.sigBytes;\r\n    const blockSizeBytes = blockSize * 4;\r\n\r\n    // Count blocks ready\r\n    let nBlocksReady = dataSigBytes / blockSizeBytes;\r\n    if (doFlush) {\r\n      // Round up to include partial blocks\r\n      nBlocksReady = Math.ceil(nBlocksReady);\r\n    } else {\r\n      // Round down to include only full blocks,\r\n      // less the number of blocks that must remain in the buffer\r\n      nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\r\n    }\r\n\r\n    // Count words ready\r\n    const nWordsReady = nBlocksReady * blockSize;\r\n\r\n    // Count bytes ready\r\n    const nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);\r\n\r\n    // Process blocks\r\n    if (nWordsReady) {\r\n      for (let offset = 0; offset < nWordsReady; offset += blockSize) {\r\n        // Perform concrete-algorithm logic\r\n        this._doProcessBlock(dataWords, offset);\r\n      }\r\n\r\n      // Remove processed words\r\n      processedWords = dataWords.splice(0, nWordsReady);\r\n      data.sigBytes -= nBytesReady;\r\n    }\r\n\r\n    // Return processed words\r\n    return new WordArray(processedWords, nBytesReady);\r\n  }\r\n\r\n  /**\r\n     * Creates a copy of this object.\r\n     *\r\n     * @return {Object} The clone.\r\n     *\r\n     * @example\r\n     *\r\n     *     var clone = bufferedBlockAlgorithm.clone();\r\n     */\r\n  clone() {\r\n    const clone = super.clone.call(this);\r\n    clone._data = this._data.clone();\r\n\r\n    return clone;\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}